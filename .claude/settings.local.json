{
  "permissions": {
    "allow": [
      "Bash(ls:*)",
      "Bash(mkdir:*)",
      "Bash(grep:*)",
      "Bash(rmdir:*)",
      "Bash(mv:*)",
      "Bash(rd:*)",
      "Bash(ren:*)",
      "Bash(rm:*)",
      "Bash(python:*)",
      "Bash(cp:*)",
      "Bash(git rm:*)",
      "Bash(git check-ignore:*)",
      "Bash(git remote add:*)",
      "Bash(git fetch:*)",
      "Bash(git push:*)",
      "Bash(find:*)",
      "Bash(dir:*)",
      "Bash(del:*)",
      "Bash(for file in *.md)",
      "Bash(do echo \"=== $file ===\")",
      "Bash(wc:*)",
      "Bash(done)",
      "Bash(for file in chapter_*.md)",
      "WebFetch(domain:en.wikipedia.org)",
      "Bash(pip install:*)",
      "Bash(where python)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_mongo_merger.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" efficient_gedcom_merger.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" simple_mongo_export.py)",
      "Bash(rg:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" comprehensive_mongo_export.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" safe_gedcom_concatenator.py)",
      "Bash(sqlite3:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_trimming_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\Gaiad.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\simple_gedcom_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\Gaiad.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\final_gedcom_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\Gaiad.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\final_gedcom_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_1200_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1200.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_flexible_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1100.ged\" 1100)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_flexible_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1000.ged\" 1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_date_scanner.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_fixed_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_fixed_trimmed_1000bc.ged\" -1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_improved_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_fixed_trimmed_1000bc.ged\" -1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_robust_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_fixed_trimmed_1000bc.ged\" -1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_date_standardizer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\date_analysis.csv\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\merged_standardized.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_robust_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\merged_standardized.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1000.ged\" -1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_simple_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1000.ged\" -1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_fast_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1000.ged\" -1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_fast_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1100.ged\" -1100)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_fast_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1200.ged\" -1200)",
      "Bash(sed:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_fast_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1000.ged\" 1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_date_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\comprehensive_date_analysis.csv\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_date_standardizer_comprehensive.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\merged_standardized_dates.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\date_standardization_log.csv\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_fast_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\merged_standardized_dates.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_standardized_trimmed_1000.ged\" 1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_fast_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1100.ged\" 1100)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_fast_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1200.ged\" 1200)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_issue_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1000.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\date_issue_summary.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\jewish_genealogy_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\merged_attempt_cleaned.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1000.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\comprehensive_date_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\comprehensive_date_analysis_v2.csv\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\improved_date_standardizer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined_standardized.ged\")",
      "Bash(git restore:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\improved_date_standardizer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_flexible_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1000.ged\" 1000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_flexible_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1100.ged\" 1100)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_flexible_trimmer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1200.ged\" 1200)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\jewish_genealogy_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\gaiad_trimmed_1000.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\comprehensive_gedcom_cleaner.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\comprehensive_gedcom_cleaner.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined_cleaned.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\comprehensive_date_analyzer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\cleaned_date_analysis.csv\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\final_date_fixer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\date_format_standardizer.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(git checkout:*)",
      "Bash(touch:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\improved_date_standardizer_v2.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\fix_negative_years.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\fix_circa_only.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\Aelaki\\aelaki_morphology.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\genealogy_issues_fixer.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\ftb_to_fh_duplicates_converter.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\gedcom_mongo_merger.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\wikidata_qid_extractor.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\evolutionism_qid_adder.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "WebFetch(domain:evolutionism.miraheze.org)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\wikibase_inspector.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\wikibase_basic_check.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\gedcom_wikibase_uploader.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\gedcom_wikibase_uploader.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\" \"1996ToOmega!\")",
      "WebFetch(domain:login.miraheze.org)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\miraheze_login_test.py\")",
      "WebFetch(domain:meta.miraheze.org)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\test_mwclient_access.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\test_session_like_working.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\refn_patch_script.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\repair_then_upload.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\chinese_repair_upload.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\chinese_genealogy_sample.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\japanese_repair_upload.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\japan_genealogy_sample.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\complete_master_uploader.py\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\new_gedcoms\\source gedcoms\\master_combined.ged\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\wikibase_discovery_mapper.py\")",
      "Bash(cat:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\japanese_gedcom_repair.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\japanese_gedcom_repair.py\" --dry-run)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\check_japanese_duplicates.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\master_gedcom_repair.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\chinese_gedcom_repair.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\master_gedcom_repair_continued.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\chinese_gedcom_creator.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\master_gedcom_creator.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\master_creator_from_i10000.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\japanese_gedcom_creator.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\master_gedcom_creator_fixed.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\database_reviewer.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\master_notes_repair.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\quick_refn_fixer.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\chinese_family_relationships.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\family_analyzer.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\japanese_family_relationships.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\master_notes_creator.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\notes_distribution_analyzer.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\chinese_relationships_working.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\japanese_relationships_working.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\family_properties_creator.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\chinese_relationships_final.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\japanese_relationships_final.py\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\quick_refn_fixer_continued.py\")",
      "Bash(echo:*)",
      "Bash(for file in *uploader*.py *repair*.py refn_patch_script.py)",
      "Bash(do if [ -f \"$file\" ])",
      "Bash(then echo -n \"$file: \")",
      "Bash(if rg -q \"''bot'': 1\" \"$file\")",
      "Bash(then echo \"DONE\")",
      "Bash(else echo \"NEEDS BOT FLAG\")",
      "Bash(fi)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" \"C:\\Users\\Immanuelle\\Documents\\Github\\Gaiad-Genealogy\\gedcom_tools\\master_relationships_final.py\")",
      "Bash(git add:*)",
      "Bash(git subtree:*)",
      "Bash(git commit:*)",
      "Bash(git read-tree:*)",
      "Bash(for file in *.py)",
      "Bash(do if rg -q \"(wbeditentity|wbcreateclaim|wbsetlabel|wbsetaliases|wbsetdescription|wbremoveclaims|''action'': ''edit'')\" \"$file\")",
      "Bash(then if ! rg -q \"''bot'': 1\" \"$file\")",
      "Bash(then echo \"NEEDS BOT FLAG: $file\")",
      "Bash(for:*)",
      "Bash(then echo \"$file\")",
      "Bash(/bashes)",
      "Bash(tasklist)",
      "Bash(taskkill:*)",
      "Bash(kill:*)",
      "Bash(git pull:*)",
      "Bash(do if rg -q \"(wbeditentity|wbcreateclaim|wbsetlabel|wbsetaliases|wbsetdescription|wbremoveclaims|''action'': ''edit'')\" \"$file\")",
      "Bash(dotnet --version)",
      "Bash(dotnet build:*)",
      "Bash(dotnet run:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" quick_refn_fixer_continued.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/quick_refn_fixer_continued.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/japanese_relationships_final.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/database_reviewer.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/master_relationships_final.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/master_notes_creator.py)",
      "Bash(timeout:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/master_multiple_names_extractor.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/master_aliases_uploader.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/gaiad_calendar_properties_creator.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/gaiad_calendar_months_creator.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/gaiad_calendar_months_simple.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/gaiad_calendar_days_creator.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/gaiad_calendar_full_creator.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" zodiac_wiki_pages.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" test_wiki_auth.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" test_single_zodiac_page.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" test_zodiac_minimal.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" debug_horus.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" trace_horus_error.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" find_53_week_years.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/long_notes_analyzer.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/substantial_notes_creator.py)",
      "Bash(tasklist:*)",
      "Bash(wmic:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/suffix_processor.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/master_relationships_from_start.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/missing_individuals_checker.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/missing_individuals_creator.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/missing_individuals_families_processor.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" check_remaining_missing.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" create_final_missing_individuals.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" create_esquire_individuals.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" debug_families_processor.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/missing_individuals_families_processor_fixed.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" get_remaining_names.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/non_latin_names_processor.py non_latin_names_with_translation_v2.csv)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/non_latin_names_processor.py non_latin_names_with_translation_v2.csv ImmanuelleBot \"1996ToOmega!\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/non_latin_names_processor.py non_latin_names_with_translation_v2.csv Immanuelle \"1996ToOmega!\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/non_latin_names_processor.py test_sample.csv Immanuelle \"1996ToOmega!\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_relationships_processor.py \"new_gedcoms/source gedcoms/master_combined.ged\" Immanuelle \"1996ToOmega!\")",
      "Bash(awk:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/master_gedcom_repair.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/database_reviewer_from_start.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/quick_refn_fixer.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/missing_individuals_relationships_fixed.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/japanese_individuals_repair.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/duplicate_properties_remover.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/duplicate_mapping_finder.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/master_relationships_narmer.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/master_relationships_middle.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/test_merger_i56212.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/auto_merger_i56212.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/complete_merger_i56212.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/bulk_duplicate_merger.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/individual_merger.py Q115039 Q126699 Q136398)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/specific_merger_q115039.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 138402 138402)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/debug_entity.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 144935 144935)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 85065 85065)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 115039 115039)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/specific_merger_q65705.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 1 160000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 65705 65705)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 90309 90309)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 144936 144936)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 600 160000)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/gedcom_aliases_uploader.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/individual_merger.py Q85820 Q97505)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/specific_merger_q85820.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/hebrew_names_processor.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/latin_alias_promoter.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/duplicate_checker.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/csv_duplicate_merger.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/wiki_xml_exporter.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/namespace_checker.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport requests\nsession = requests.Session()\nsession.headers.update({''User-Agent'': ''Test''})\n\n# Check multiple namespaces for Q entities\nfor ns in [0, 860]:\n    params = {\n        ''action'': ''query'',\n        ''list'': ''allpages'',\n        ''apnamespace'': ns,\n        ''aplimit'': 5,\n        ''apprefix'': ''Q'',\n        ''format'': ''json''\n    }\n    \n    response = session.get(''https://evolutionism.miraheze.org/w/api.php'', params=params)\n    data = response.json()\n    \n    if ''query'' in data and ''allpages'' in data[''query'']:\n        pages = data[''query''][''allpages'']\n        if pages:\n            print(f''Namespace {ns}: Found {len(pages)} Q pages'')\n            for page in pages[:3]:\n                print(f''  {page[\"\"title\"\"]}'')\n        else:\n            print(f''Namespace {ns}: No Q pages found'')\n\")",
      "Bash(docker-compose up:*)",
      "Bash(docker:*)",
      "Bash(where docker)",
      "Bash(Get-Command docker -ErrorAction SilentlyContinue)",
      "Bash(refreshenv)",
      "Bash(export PATH=\"$PATH:/c/Program Files/Docker/Docker/resources/bin\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/simple_xml_export.py)",
      "Bash(curl:*)",
      "Bash(net start:*)",
      "Bash(\"C:\\Program Files\\Docker\\Docker\\Docker Desktop.exe\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 18001 160000 Immanuelle \"1996ToOmega!\" http://localhost:8080)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 1 10 Immanuelle \"1996ToOmega!\" http://localhost:8080)",
      "Bash(do echo:*)",
      "Bash(head:*)",
      "Bash(php:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 18001 160000 Immanuelle \"1996ToOmega!\")",
      "Bash(wsl:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/property_exporter.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer_resumable.py 18001 160000 Immanuelle \"1996ToOmega!\" http://localhost:8080)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/comprehensive_database_fixer.py 21001 160000 Immanuelle \"1996ToOmega!\" http://localhost:8080)",
      "Bash(where mongod)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -m pip install pymongo python-Levenshtein)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\ntry:\n    client = pymongo.MongoClient(''mongodb://localhost:27017/'', serverSelectionTimeoutMS=5000)\n    client.server_info()\n    print(''✓ MongoDB connection successful'')\n    print(''✓ Server info:'', client.server_info()[''version''])\n    client.close()\nexcept Exception as e:\n    print(''✗ MongoDB connection failed:'', e)\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\ntry:\n    client = pymongo.MongoClient(''mongodb://localhost:27017/'', serverSelectionTimeoutMS=5000)\n    client.server_info()\n    print(''MongoDB connection successful'')\n    print(''Server version:'', client.server_info()[''version''])\n    \n    # Test new database\n    db = client[''gaiad_processing_db'']\n    collection = db[''test'']\n    collection.insert_one({''test'': ''data''})\n    print(''Database gaiad_processing_db created successfully'')\n    client.close()\nexcept Exception as e:\n    print(''MongoDB connection failed:'', str(e))\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/mongodb_pipeline.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/mongodb_xml_importer.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/debug_xml_parser.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/mongodb_pipeline.py merge)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/mongodb_pipeline.py export)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== PROPERTY ANALYSIS ==='')\nprint()\n\n# Get all unique property IDs\npipeline = [\n    {''$project'': {''properties'': {''$objectToArray'': ''$properties''}}},\n    {''$unwind'': ''$properties''},\n    {''$group'': {''_id'': ''$properties.k'', ''count'': {''$sum'': 1}}},\n    {''$sort'': {''count'': -1}}\n]\n\nprint(''Top 20 most common properties:'')\nfor result in collection.aggregate(pipeline):\n    if result[''count''] > 100:  # Only show common ones\n        print(f''{result[\"\"_id\"\"]}: {result[\"\"count\"\"]:,} entities'')\n\nprint()\nprint(''=== SEX PROPERTY CHECK ==='')\n# Check for sex-related properties\nsex_props = [''P11'', ''P21'', ''P55'', ''P21'']\nfor prop in sex_props:\n    count = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    print(f''{prop}: {count:,} entities'')\n    \n    if count > 0:\n        # Show sample values\n        sample = collection.find_one({f''properties.{prop}'': {''$exists'': True}})\n        if sample and prop in sample.get(''properties'', {}):\n            values = sample[''properties''][prop][:3]  # First 3 claims\n            print(f''  Sample values: {values}'')\n\nprint()\nprint(''=== DATE PROPERTY CHECK ==='')\n# Check for date properties\ndate_props = [''P7'', ''P8'', ''P56'', ''P57'', ''P569'', ''P570'']\nfor prop in date_props:\n    count = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    print(f''{prop}: {count:,} entities'')\n    \n    if count > 0:\n        # Show sample values\n        sample = collection.find_one({f''properties.{prop}'': {''$exists'': True}})\n        if sample and prop in sample.get(''properties'', {}):\n            values = sample[''properties''][prop][:3]\n            print(f''  Sample values: {values}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== QUICK PROPERTY ANALYSIS ==='')\nprint()\n\n# Sample a few entities to see what properties exist\nsample_entities = list(collection.find().limit(100))\nall_props = Counter()\n\nfor entity in sample_entities:\n    if ''properties'' in entity:\n        for prop_id in entity[''properties''].keys():\n            all_props[prop_id] += 1\n\nprint(''Properties found in sample of 100 entities:'')\nfor prop, count in all_props.most_common(20):\n    print(f''{prop}: {count} entities'')\n\nprint()\nprint(''=== SEX PROPERTY CHECK ==='')\n# Check for sex-related properties\nsex_props = [''P11'', ''P21'', ''P55'', ''P569'']\nfor prop in sex_props:\n    count = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    print(f''{prop}: {count:,} entities'')\n    \n    if count > 0:\n        # Show sample\n        sample = collection.find_one({f''properties.{prop}'': {''$exists'': True}})\n        if sample and prop in sample.get(''properties'', {}):\n            print(f''  Sample: {sample[\"\"properties\"\"][prop][:2]}'')\n\nprint()\nprint(''=== DATE PROPERTY CHECK ==='')\n# Check for date properties  \ndate_props = [''P7'', ''P8'', ''P56'', ''P57'', ''P569'', ''P570'']\nfor prop in date_props:\n    count = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    print(f''{prop}: {count:,} entities'')\n    \n    if count > 0:\n        sample = collection.find_one({f''properties.{prop}'': {''$exists'': True}})\n        if sample and prop in sample.get(''properties'', {}):\n            print(f''  Sample: {sample[\"\"properties\"\"][prop][:2]}'')\n\nprint()\nprint(''=== GENI ID CHECK ==='')\n# Check P41 REFN values\nrefn_count = collection.count_documents({''properties.P41'': {''$exists'': True}})\nprint(f''P41 (REFN): {refn_count:,} entities'')\n\nif refn_count > 0:\n    # Look at sample REFN values\n    samples = list(collection.find({''properties.P41'': {''$exists'': True}}).limit(20))\n    print(''Sample REFN values:'')\n    for sample in samples[:10]:\n        refn_claims = sample[''properties''][''P41'']\n        for claim in refn_claims[:3]:  # First 3 claims\n            value = claim.get(''value'', '''')\n            print(f''  {value}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== PROCESSED DATA ANALYSIS ==='')\nprint()\n\n# Check what we actually have\ntotal = collection.count_documents({})\nprint(f''Total entities: {total:,}'')\n\n# Check processed properties\np55_count = collection.count_documents({''properties.P55'': {''$exists'': True}})\np56_count = collection.count_documents({''properties.P56'': {''$exists'': True}})  \np57_count = collection.count_documents({''properties.P57'': {''$exists'': True}})\np44_count = collection.count_documents({''properties.P44'': {''$exists'': True}})\np43_count = collection.count_documents({''properties.P43'': {''$exists'': True}})\n\nprint(f''P55 (sex - processed): {p55_count:,} entities'')\nprint(f''P56 (birth date - processed): {p56_count:,} entities'')\nprint(f''P57 (death date - processed): {p57_count:,} entities'') \nprint(f''P44 (Wikidata QID): {p44_count:,} entities'')\nprint(f''P43 (Geni ID): {p43_count:,} entities'')\n\nprint()\nprint(''=== SAMPLE DATA ==='')\n\n# Show samples\nif p55_count > 0:\n    sample = collection.find_one({''properties.P55'': {''$exists'': True}})\n    print(f''P55 sample: {sample[\"\"properties\"\"][\"\"P55\"\"][:2]}'')\n\nif p56_count > 0:\n    sample = collection.find_one({''properties.P56'': {''$exists'': True}})\n    print(f''P56 sample: {sample[\"\"properties\"\"][\"\"P56\"\"][:2]}'')\n\nif p44_count > 0:\n    sample = collection.find_one({''properties.P44'': {''$exists'': True}})  \n    print(f''P44 sample: {sample[\"\"properties\"\"][\"\"P44\"\"][:2]}'')\n\nif p43_count > 0:\n    sample = collection.find_one({''properties.P43'': {''$exists'': True}})\n    print(f''P43 sample: {sample[\"\"properties\"\"][\"\"P43\"\"][:2]}'')\n\nprint()\nprint(''=== CHECK FOR REFERENCE_NUMBERS ==='')\n# Check for REFERENCE_NUMBERS in various places\ndesc_ref = collection.count_documents({''descriptions.en'': {''$regex'': ''REFERENCE_NUMBERS''}})\nlabel_ref = collection.count_documents({''labels.en'': {''$regex'': ''REFERENCE_NUMBERS''}})\n\nprint(f''Descriptions with REFERENCE_NUMBERS: {desc_ref:,}'')\nprint(f''Labels with REFERENCE_NUMBERS: {label_ref:,}'')\n\nif desc_ref > 0:\n    sample = collection.find_one({''descriptions.en'': {''$regex'': ''REFERENCE_NUMBERS''}})\n    print(f''Sample description: {sample[\"\"descriptions\"\"][\"\"en\"\"][:200]}...'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DATABASE STATE INVESTIGATION ==='')\nprint()\n\n# Get a few random entities and see what they look like\nsamples = list(collection.find().limit(5))\n\nfor i, entity in enumerate(samples):\n    print(f''--- ENTITY {i+1}: {entity[\"\"qid\"\"]} ---'')\n    print(f''Type: {entity[\"\"entity_type\"\"]}'')\n    print(f''Labels: {list(entity.get(\"\"labels\"\", {}).keys())}'')\n    print(f''Descriptions: {list(entity.get(\"\"descriptions\"\", {}).keys())}'')\n    print(f''Properties: {list(entity.get(\"\"properties\"\", {}).keys())}'')\n    \n    # Show some property details\n    props = entity.get(''properties'', {})\n    for prop_id in list(props.keys())[:5]:  # First 5 properties\n        claims = props[prop_id]\n        print(f''  {prop_id}: {len(claims)} claims'')\n        if claims:\n            print(f''    Sample: {claims[0]}'')\n    print()\n\n# Check if there are any entities with the specific properties we''re looking for\nprint(''=== SPECIFIC PROPERTY SEARCH ==='')\nfor prop in [''P11'', ''P7'', ''P8'', ''P41'', ''P44'', ''P43'', ''P55'', ''P56'', ''P57'']:\n    count = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    if count > 0:\n        print(f''{prop}: {count:,} entities'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== ACCURATE PROPERTY COUNTS ==='')\nprint()\n\nproperties_to_check = [''P11'', ''P7'', ''P8'', ''P41'', ''P44'', ''P43'', ''P55'', ''P56'', ''P57'', ''P39'']\n\nfor prop in properties_to_check:\n    count = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    print(f''{prop}: {count:,} entities'')\n    \n    # Show a sample if it exists\n    if count > 0:\n        sample = collection.find_one({f''properties.{prop}'': {''$exists'': True}})\n        sample_claims = sample[''properties''][prop][:2]  # First 2 claims\n        print(f''  Sample: {sample_claims}'')\n        print()\n\nprint()\nprint(''=== ANALYSIS ==='')\n\n# Count entities with Wikidata QIDs\np44_count = collection.count_documents({''properties.P44'': {''$exists'': True}})\n# Count entities with Geni IDs  \np43_count = collection.count_documents({''properties.P43'': {''$exists'': True}})\n# Count entities with ''no identifiers''\np39_no_id = collection.count_documents({\n    ''properties.P39.value'': ''Q153720''\n})\n\nprint(f''Entities with Wikidata QIDs (P44): {p44_count:,}'')\nprint(f''Entities with Geni IDs (P43): {p43_count:,}'')  \nprint(f''Entities marked as no identifiers: {p39_no_id:,}'')\n\n# Check sex properties\np55_count = collection.count_documents({''properties.P55'': {''$exists'': True}})\nprint(f''Entities with sex property (P55): {p55_count:,}'')\n\n# Check date properties\np56_count = collection.count_documents({''properties.P56'': {''$exists'': True}})\np57_count = collection.count_documents({''properties.P57'': {''$exists'': True}})\nprint(f''Entities with birth date (P56): {p56_count:,}'')\nprint(f''Entities with death date (P57): {p57_count:,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DIRECT QUERY DEBUG ==='')\n\n# Find the specific entities I saw earlier\nq16244 = collection.find_one({''qid'': ''Q16244''})\nif q16244:\n    print(f''Q16244 properties: {list(q16244.get(\"\"properties\"\", {}).keys())}'')\n    if ''P44'' in q16244.get(''properties'', {}):\n        print(f''Q16244 P44: {q16244[\"\"properties\"\"][\"\"P44\"\"]}'')\n\n# Try a different query approach\nentities_with_p44 = list(collection.find({''properties.P44'': {''$exists'': True}}).limit(5))\nprint(f''Found {len(entities_with_p44)} entities with P44 using find()'')\n\n# Try aggregate to count\ntry:\n    pipeline = [\n        {''$match'': {''properties.P44'': {''$exists'': True}}},\n        {''$count'': ''total''}\n    ]\n    result = list(collection.aggregate(pipeline))\n    print(f''Aggregate count for P44: {result}'')\nexcept Exception as e:\n    print(f''Aggregate error: {e}'')\n\n# Manual count\nmanual_count = 0\nfor entity in collection.find().limit(1000):\n    if ''P44'' in entity.get(''properties'', {}):\n        manual_count += 1\n\nprint(f''Manual count of P44 in first 1000: {manual_count}'')\n\n# Check if MongoDB is working correctly\ntotal_docs = collection.count_documents({})\nprint(f''Total documents: {total_docs:,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/property_analyzer.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== P41 GENI REFERENCE SEARCH ==='')\nprint()\n\ngeni_found = 0\ngeni_samples = []\n\nprint(''Searching through all P41 properties for \"\"geni\"\" references...'')\nprocessed = 0\n\nfor entity in collection.find({''properties.P41'': {''$exists'': True}}):\n    processed += 1\n    if processed % 5000 == 0:\n        print(f''  Checked {processed:,} entities with P41...'')\n    \n    qid = entity[''qid'']\n    p41_claims = entity.get(''properties'', {}).get(''P41'', [])\n    \n    for claim in p41_claims:\n        value = claim.get(''value'', '''')\n        if isinstance(value, str) and ''geni'' in value.lower():\n            geni_found += 1\n            if len(geni_samples) < 10:  # Collect first 10 samples\n                geni_samples.append({\n                    ''qid'': qid,\n                    ''value'': value,\n                    ''claim'': claim\n                })\n\nprint(f''  Checked {processed:,} entities with P41 total'')\nprint()\n\nprint(f''Found {geni_found:,} P41 claims containing \"\"geni\"\"'')\n\nif geni_samples:\n    print()\n    print(''Sample Geni references:'')\n    for sample in geni_samples:\n        print(f''  {sample[\"\"qid\"\"]}: {sample[\"\"value\"\"]}'')\n\n# Also check for different formats\nprint()\nprint(''=== CHECKING OTHER GENI FORMATS ==='')\n\n# Check for numeric patterns that might be Geni IDs\nnumeric_patterns = 0\nurl_patterns = 0\nother_patterns = 0\n\nsample_count = 0\nfor entity in collection.find({''properties.P41'': {''$exists'': True}}).limit(1000):\n    p41_claims = entity.get(''properties'', {}).get(''P41'', [])\n    \n    for claim in p41_claims:\n        value = claim.get(''value'', '''')\n        if isinstance(value, str):\n            if value.isdigit() and len(value) >= 6:  # Potential Geni ID\n                numeric_patterns += 1\n                if sample_count < 5:\n                    print(f''  Numeric (potential Geni): {entity[\"\"qid\"\"]} = {value}'')\n                    sample_count += 1\n            elif ''http'' in value.lower() and ''geni'' in value.lower():\n                url_patterns += 1\n            elif len(value) > 20:  # Long string that might contain Geni info\n                other_patterns += 1\n\nprint(f''In sample of 1000 entities:'')\nprint(f''  Numeric patterns (6+ digits): {numeric_patterns}'')\nprint(f''  URL patterns with geni: {url_patterns}'')\nprint(f''  Other long strings: {other_patterns}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DIRECT P41 INVESTIGATION ==='')\nprint()\n\n# Find some entities that should have P41\nsample_entities = list(collection.find().limit(100))\n\np41_count = 0\np41_samples = []\n\nfor entity in sample_entities:\n    properties = entity.get(''properties'', {})\n    if ''P41'' in properties:\n        p41_count += 1\n        if len(p41_samples) < 5:\n            p41_samples.append({\n                ''qid'': entity[''qid''],\n                ''p41_claims'': properties[''P41''][:3]  # First 3 claims\n            })\n\nprint(f''Found {p41_count} entities with P41 in sample of {len(sample_entities)}'')\nprint()\n\nif p41_samples:\n    print(''Sample P41 properties:'')\n    for sample in p41_samples:\n        print(f''{sample[\"\"qid\"\"]}:'')\n        for claim in sample[''p41_claims'']:\n            value = claim.get(''value'', '''')\n            claim_type = claim.get(''type'', '''')\n            print(f''  Value: \"\"{value}\"\" (type: {claim_type})'')\n            \n            # Check for Geni patterns\n            if isinstance(value, str):\n                if ''geni'' in value.lower():\n                    print(f''    -> CONTAINS GENI!'')\n                elif value.isdigit() and len(value) >= 6:\n                    print(f''    -> NUMERIC (potential Geni ID)'')\n                elif value.startswith(''Q'') and value[1:].isdigit():\n                    print(f''    -> WIKIDATA QID'')\n        print()\n\n# Also try the MongoDB exists query to see why it''s not working\nprint(''=== MONGODB QUERY DEBUG ==='')\ntry:\n    # Try different query approaches\n    count1 = collection.count_documents({''properties.P41'': {''$exists'': True}})\n    print(f''count_documents with $exists: {count1}'')\n    \n    # Manual count\n    manual_count = 0\n    for entity in collection.find().limit(1000):\n        if ''P41'' in entity.get(''properties'', {}):\n            manual_count += 1\n    print(f''Manual count in first 1000: {manual_count}'')\n    \nexcept Exception as e:\n    print(f''Query error: {e}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== COMPREHENSIVE DATABASE CHECK ==='')\nprint()\n\n# Check what properties actually exist\nall_properties = set()\nentity_count = 0\n\nfor entity in collection.find().limit(10000):  # Check first 10k\n    entity_count += 1\n    properties = entity.get(''properties'', {})\n    all_properties.update(properties.keys())\n\nprint(f''Checked {entity_count} entities'')\nprint(f''Found these properties: {sorted(all_properties)}'')\n\n# Count each property in the first 10k entities\nfrom collections import Counter\nprop_counts = Counter()\n\nfor entity in collection.find().limit(10000):\n    properties = entity.get(''properties'', {})\n    for prop in properties.keys():\n        prop_counts[prop] += 1\n\nprint()\nprint(''Property counts in first 10,000 entities:'')\nfor prop, count in sorted(prop_counts.items()):\n    print(f''  {prop}: {count:,}'')\n\n# Check if P41 exists anywhere\nprint()\nprint(''=== SPECIFIC P41 CHECK ==='')\np41_found = False\n\nfor entity in collection.find().limit(10000):\n    if ''P41'' in entity.get(''properties'', {}):\n        p41_found = True\n        print(f''Found P41 in entity {entity[\"\"qid\"\"]}'')\n        print(f''P41 claims: {entity[\"\"properties\"\"][\"\"P41\"\"]}'')\n        break\n\nif not p41_found:\n    print(''No P41 properties found in first 10,000 entities'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport re\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== P41 GENI SEARCH ==='')\nprint()\n\n# Count different types of P41 values\ngeni_references = 0\nnumeric_ids = []\nwikidata_qids = []\nhex_ids = []\nurl_references = []\nother_formats = []\n\nprocessed = 0\nfor entity in collection.find().limit(20000):  # Check first 20k entities\n    processed += 1\n    if processed % 5000 == 0:\n        print(f''  Processed {processed:,} entities...'')\n        \n    properties = entity.get(''properties'', {})\n    if ''P41'' in properties:\n        for claim in properties[''P41'']:\n            value = claim.get(''value'', '''')\n            if isinstance(value, str) and value.strip():\n                value = value.strip()\n                \n                # Check for different patterns\n                if ''geni'' in value.lower():\n                    geni_references += 1\n                    print(f''  GENI FOUND: {entity[\"\"qid\"\"]} = \"\"{value}\"\"'')\n                    \n                elif re.match(r''^\\d{6,}$'', value):  # 6+ digit number\n                    numeric_ids.append((entity[''qid''], value))\n                    \n                elif re.match(r''^Q\\d+$'', value):  # Wikidata QID\n                    wikidata_qids.append((entity[''qid''], value))\n                    \n                elif re.match(r''^[A-F0-9]{20,}$'', value):  # Hex ID\n                    hex_ids.append((entity[''qid''], value))\n                    \n                elif value.startswith(''http''):  # URL\n                    url_references.append((entity[''qid''], value))\n                    \n                else:\n                    other_formats.append((entity[''qid''], value))\n\nprint(f''  Processed {processed:,} entities total'')\nprint()\n\nprint(''=== P41 VALUE ANALYSIS ==='')\nprint(f''Geni references: {geni_references:,}'')\nprint(f''Numeric IDs (6+ digits): {len(numeric_ids):,}'')\nprint(f''Wikidata QIDs: {len(wikidata_qids):,}'')  \nprint(f''Hex IDs: {len(hex_ids):,}'')\nprint(f''URL references: {len(url_references):,}'')\nprint(f''Other formats: {len(other_formats):,}'')\n\nprint()\nprint(''=== SAMPLES ==='')\n\nif numeric_ids:\n    print(''Sample numeric IDs (potential Geni):'')\n    for qid, value in numeric_ids[:5]:\n        print(f''  {qid}: {value}'')\n\nif wikidata_qids:\n    print(''Sample Wikidata QIDs:'')\n    for qid, value in wikidata_qids[:5]:\n        print(f''  {qid}: {value}'')\n        \nif hex_ids:\n    print(''Sample hex IDs:'')\n    for qid, value in hex_ids[:3]:\n        print(f''  {qid}: {value}'')\n\nif other_formats:\n    print(''Sample other formats:'')\n    for qid, value in other_formats[:5]:\n        print(f''  {qid}: {value[:50]}...'' if len(value) > 50 else f''  {qid}: {value}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/mongodb_bulk_processor.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== INVESTIGATING SEX/DATE PROPERTY ISSUE ==='')\nprint()\n\n# Check if P11 entities exist and what they look like\nprint(''Looking for P11 entities...'')\np11_samples = list(collection.find({''properties.P11'': {''$exists'': True}}).limit(5))\nprint(f''Found {len(p11_samples)} P11 entities in sample'')\n\nfor sample in p11_samples:\n    print(f''Entity {sample[\"\"qid\"\"]}:'')\n    p11_claims = sample[''properties''][''P11'']\n    for claim in p11_claims[:3]:\n        print(f''  P11 claim: {claim}'')\n        value = claim.get(''value'', '''')\n        claim_type = claim.get(''type'', '''')\n        print(f''  Value: \"\"{value}\"\" Type: \"\"{claim_type}\"\"'')\n    print()\n\n# Check if P7 entities exist\nprint(''Looking for P7 entities...'')\np7_samples = list(collection.find({''properties.P7'': {''$exists'': True}}).limit(3))\nprint(f''Found {len(p7_samples)} P7 entities in sample'')\n\nfor sample in p7_samples:\n    print(f''Entity {sample[\"\"qid\"\"]}:'')\n    p7_claims = sample[''properties''][''P7'']\n    for claim in p7_claims[:2]:\n        print(f''  P7 claim: {claim}'')\n    print()\n\n# Check if P8 entities exist\nprint(''Looking for P8 entities...'')\np8_samples = list(collection.find({''properties.P8'': {''$exists'': True}}).limit(3))\nprint(f''Found {len(p8_samples)} P8 entities in sample'')\n\nfor sample in p8_samples:\n    print(f''Entity {sample[\"\"qid\"\"]}:'')\n    p8_claims = sample[''properties''][''P8'']\n    for claim in p8_claims[:2]:\n        print(f''  P8 claim: {claim}'')\n    print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/process_remaining_properties.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/debug_property_structure.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/process_edge_case_properties.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== REMAINING P7 SAMPLES ==='')\np7_samples = []\nfor entity in collection.find({''properties.P7'': {''$exists'': True}}).limit(10):\n    p7_claims = entity[''properties''][''P7'']\n    for claim in p7_claims[:2]:\n        p7_samples.append({\n            ''qid'': entity[''qid''],\n            ''value'': claim.get(''value''),\n            ''type'': claim.get(''type'')\n        })\n\nfor sample in p7_samples[:10]:\n    print(f''{sample[\"\"qid\"\"]}: {sample[\"\"value\"\"]} (type: {sample[\"\"type\"\"]})'')\n\nprint()\nprint(''=== REMAINING P8 SAMPLES ==='')\np8_samples = []\nfor entity in collection.find({''properties.P8'': {''$exists'': True}}).limit(10):\n    p8_claims = entity[''properties''][''P8'']\n    for claim in p8_claims[:2]:\n        p8_samples.append({\n            ''qid'': entity[''qid''],\n            ''value'': claim.get(''value''),\n            ''type'': claim.get(''type'')\n        })\n\nfor sample in p8_samples[:10]:\n    print(f''{sample[\"\"qid\"\"]}: {sample[\"\"value\"\"]} (type: {sample[\"\"type\"\"]})'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Direct count check\np7_count = collection.count_documents({''properties.P7'': {''$exists'': True}})\np8_count = collection.count_documents({''properties.P8'': {''$exists'': True}})\np11_count = collection.count_documents({''properties.P11'': {''$exists'': True}})\n\nprint(f''Direct MongoDB queries:'')\nprint(f''P7 entities: {p7_count}'')\nprint(f''P8 entities: {p8_count}'')\nprint(f''P11 entities: {p11_count}'')\n\nif p7_count > 0:\n    print()\n    print(''=== P7 SAMPLE ==='')\n    sample = collection.find_one({''properties.P7'': {''$exists'': True}})\n    if sample:\n        print(f''Entity: {sample[\"\"qid\"\"]}'')\n        print(f''P7: {sample[\"\"properties\"\"][\"\"P7\"\"]}'')\n\nif p8_count > 0:\n    print()\n    print(''=== P8 SAMPLE ==='')\n    sample = collection.find_one({''properties.P8'': {''$exists'': True}})\n    if sample:\n        print(f''Entity: {sample[\"\"qid\"\"]}'')\n        print(f''P8: {sample[\"\"properties\"\"][\"\"P8\"\"]}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DEBUGGING PROPERTY COUNT DISCREPANCY ==='')\nprint()\n\n# Manual property counting like the analyzer does\nproperty_counts = Counter()\nprocessed = 0\n\nfor entity in collection.find():\n    processed += 1\n    if processed % 20000 == 0:\n        print(f''Processed {processed:,} entities...'')\n    \n    properties = entity.get(''properties'', {})\n    for prop_id in properties.keys():\n        property_counts[prop_id] += 1\n\nprint(f''Processed {processed:,} entities total'')\nprint()\n\n# Check for P7, P8, P11\nfor prop in [''P7'', ''P8'', ''P11'']:\n    count = property_counts.get(prop, 0)\n    print(f''{prop}: {count} entities'')\n    \n    if count > 0:\n        # Find a sample\n        sample = collection.find_one({f''properties.{prop}'': {''$exists'': True}})\n        if sample:\n            print(f''  Sample: {sample[\"\"qid\"\"]} has {prop}'')\n        else:\n            print(f''  No sample found despite count of {count}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== INVESTIGATING PHANTOM PROPERTIES ==='')\nprint()\n\nfound_p7 = 0\nfound_p8 = 0\nchecked = 0\n\nfor entity in collection.find():\n    checked += 1\n    if checked % 20000 == 0:\n        print(f''Checked {checked:,} entities...'')\n    \n    properties = entity.get(''properties'', {})\n    qid = entity[''qid'']\n    \n    if ''P7'' in properties:\n        found_p7 += 1\n        if found_p7 <= 5:  # Show first 5 examples\n            print(f''FOUND P7 in {qid}: {properties[\"\"P7\"\"]}'')\n    \n    if ''P8'' in properties:\n        found_p8 += 1\n        if found_p8 <= 5:  # Show first 5 examples\n            print(f''FOUND P8 in {qid}: {properties[\"\"P8\"\"]}'')\n    \n    # Stop after finding some examples\n    if found_p7 >= 5 and found_p8 >= 5:\n        break\n\nprint(f''Manual search found: P7={found_p7}, P8={found_p8} in first {checked:,} entities'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/process_bc_dates.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL 5 REMAINING P7 ENTITIES ==='')\n\ncount = 0\nfor entity in collection.find({''properties.P7'': {''$exists'': True}}):\n    count += 1\n    qid = entity[''qid'']\n    p7_claims = entity[''properties''][''P7'']\n    \n    print(f''{count}. {qid}:'')\n    for claim in p7_claims:\n        value = claim.get(''value'')\n        if isinstance(value, dict) and ''text'' in value:\n            print(f''   Value: \"\"{value[\"\"text\"\"]}\"\"'')\n        else:\n            print(f''   Value: \"\"{value}\"\"'')\n        print(f''   Type: {claim.get(\"\"type\"\")}'')\n        print(f''   Claim ID: {claim.get(\"\"claim_id\"\")}'')\n    print()\n\nprint(f''Total remaining P7 entities: {count}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Final verification counts\np11_count = collection.count_documents({''properties.P11'': {''$exists'': True}})\np7_count = collection.count_documents({''properties.P7'': {''$exists'': True}})\np8_count = collection.count_documents({''properties.P8'': {''$exists'': True}})\np41_count = collection.count_documents({''properties.P41'': {''$exists'': True}})\n\n# Processed counts\np55_count = collection.count_documents({''properties.P55'': {''$exists'': True}})\np56_count = collection.count_documents({''properties.P56'': {''$exists'': True}})\np57_count = collection.count_documents({''properties.P57'': {''$exists'': True}})\np44_count = collection.count_documents({''properties.P44'': {''$exists'': True}})\np43_count = collection.count_documents({''properties.P43'': {''$exists'': True}})\np60_count = collection.count_documents({''properties.P60'': {''$exists'': True}})\n\nprint(''=== FINAL PROCESSING SUMMARY ==='')\nprint()\nprint(''UNPROCESSED (should be 0):'')\nprint(f''P11 sex properties: {p11_count}'')\nprint(f''P7 birth dates: {p7_count}'')\nprint(f''P8 death dates: {p8_count}'')\nprint(f''P41 REFN properties: {p41_count}'')\nprint()\nprint(''PROCESSED (converted):'')\nprint(f''P55 sex properties: {p55_count:,}'')\nprint(f''P56 birth dates: {p56_count:,}'')\nprint(f''P57 death dates: {p57_count:,}'')\nprint(f''P44 Wikidata QIDs: {p44_count:,}'')\nprint(f''P43 Geni IDs: {p43_count:,}'')\nprint(f''P60 UUID REFNs: {p60_count:,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== COMPREHENSIVE FINAL VERIFICATION ==='')\nprint()\n\n# Manual count of all properties\nproperty_counts = Counter()\ntotal_entities = 0\n\nfor entity in collection.find():\n    total_entities += 1\n    properties = entity.get(''properties'', {})\n    for prop_id in properties.keys():\n        property_counts[prop_id] += 1\n\nprint(f''Total entities: {total_entities:,}'')\nprint()\n\n# Key properties\nkey_props = [''P11'', ''P7'', ''P8'', ''P41'', ''P55'', ''P56'', ''P57'', ''P44'', ''P43'', ''P60'']\nfor prop in key_props:\n    count = property_counts.get(prop, 0)\n    print(f''{prop}: {count:,} entities'')\n\nprint()\nprint(''=== PROCESSING STATUS ==='')\nprint(f''P11 -> P55 conversion: {\"COMPLETE\" if property_counts.get(\"P11\", 0) == 0 else \"INCOMPLETE\"}'')\nprint(f''P7 -> P56 conversion: {\"COMPLETE\" if property_counts.get(\"P7\", 0) == 0 else \"INCOMPLETE\"}'')\nprint(f''P8 -> P57 conversion: {\"COMPLETE\" if property_counts.get(\"P8\", 0) == 0 else \"INCOMPLETE\"}'')\nprint(f''P41 -> P44/P43/P60 conversion: {\"COMPLETE\" if property_counts.get(\"P41\", 0) == 0 else \"INCOMPLETE\"}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL 5 REMAINING P7 BIRTH DATES ==='')\nprint()\n\n# Find entities with P7 properties by manual search\nfound_entities = []\ncount = 0\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''P7'' in properties:\n        found_entities.append(entity)\n        count += 1\n        if count >= 10:  # Get up to 10 to be safe\n            break\n\nprint(f''Found {len(found_entities)} entities with P7 properties:'')\nprint()\n\nfor i, entity in enumerate(found_entities, 1):\n    qid = entity[''qid'']\n    p7_claims = entity[''properties''][''P7'']\n    \n    print(f''{i}. {qid}:'')\n    \n    # Show entity label if available\n    label = entity.get(''labels'', {}).get(''en'', ''No label'')\n    print(f''   Label: \"\"{label}\"\"'')\n    \n    for j, claim in enumerate(p7_claims):\n        value = claim.get(''value'', {})\n        if isinstance(value, dict) and ''text'' in value:\n            date_text = value[''text'']\n            language = value.get(''language'', ''unknown'')\n            print(f''   Birth Date {j+1}: \"\"{date_text}\"\" (language: {language})'')\n        else:\n            print(f''   Birth Date {j+1}: \"\"{value}\"\"'')\n        \n        claim_type = claim.get(''type'', ''unknown'')\n        claim_id = claim.get(''claim_id'', ''no ID'')\n        print(f''   Type: {claim_type}'')\n        print(f''   Claim ID: {claim_id}'')\n        print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Check P41 count\np41_count = collection.count_documents({''properties.P41'': {''$exists'': True}})\nprint(f''P41 (REFN) properties remaining: {p41_count}'')\n\nif p41_count == 0:\n    print(''✅ P41 completely processed and removed'')\n    print()\n    print(''All P41 REFN values were successfully converted to:'')\n    \n    # Show what they became\n    p44_count = collection.count_documents({''properties.P44'': {''$exists'': True}})\n    p43_count = collection.count_documents({''properties.P43'': {''$exists'': True}}) \n    p60_count = collection.count_documents({''properties.P60'': {''$exists'': True}})\n    \n    print(f''• P44 (Wikidata QIDs): {p44_count:,} entities'')\n    print(f''• P43 (Geni IDs): {p43_count:,} entities'')  \n    print(f''• P60 (UUID REFNs): {p60_count:,} entities'')\n    \n    total_converted = p44_count + p43_count + p60_count\n    print(f''• Total converted from P41: {total_converted:,} entities'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Check P41 count\np41_count = collection.count_documents({''properties.P41'': {''$exists'': True}})\nprint(f''P41 (REFN) properties remaining: {p41_count}'')\n\nif p41_count == 0:\n    print(''OK P41 completely processed and removed'')\n    print()\n    print(''All P41 REFN values were successfully converted to:'')\n    \n    # Show what they became\n    p44_count = collection.count_documents({''properties.P44'': {''$exists'': True}})\n    p43_count = collection.count_documents({''properties.P43'': {''$exists'': True}}) \n    p60_count = collection.count_documents({''properties.P60'': {''$exists'': True}})\n    \n    print(f''  P44 (Wikidata QIDs): {p44_count:,} entities'')\n    print(f''  P43 (Geni IDs): {p43_count:,} entities'')  \n    print(f''  P60 (UUID REFNs): {p60_count:,} entities'')\n    \n    total_converted = p44_count + p43_count + p60_count\n    print(f''  Total converted from P41: {total_converted:,} entities'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/migrate_identifier_properties.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== REMAINING P44 ENTITIES ==='')\nremaining = list(collection.find({''properties.P44'': {''$exists'': True}}))\nprint(f''Found {len(remaining)} entities with P44'')\n\nfor entity in remaining:\n    qid = entity[''qid'']\n    p44_claims = entity[''properties''][''P44'']\n    print(f''{qid}:'')\n    for claim in p44_claims:\n        value = claim.get(''value'')\n        claim_type = claim.get(''type'')\n        print(f''  Value: \"\"{value}\"\" Type: {claim_type}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== IDENTIFIER OVERLAP ANALYSIS ==='')\nprint()\n\n# Count entities with each type\ntotal_entities = collection.count_documents({})\nwikidata_only = collection.count_documents({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.P62'': {''$exists'': False}\n})\ngeni_only = collection.count_documents({\n    ''properties.P61'': {''$exists'': False},\n    ''properties.P62'': {''$exists'': True}\n})\nboth_wikidata_geni = collection.count_documents({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.P62'': {''$exists'': True}\n})\nwikidata_total = collection.count_documents({''properties.P61'': {''$exists'': True}})\ngeni_total = collection.count_documents({''properties.P62'': {''$exists'': True}})\nuuid_total = collection.count_documents({''properties.P63'': {''$exists'': True}})\nno_identifiers = collection.count_documents({\n    ''properties.P61'': {''$exists'': False},\n    ''properties.P62'': {''$exists'': False},\n    ''properties.P63'': {''$exists'': False}\n})\n\nprint(f''Total entities: {total_entities:,}'')\nprint()\nprint(''IDENTIFIER BREAKDOWN:'')\nprint(f''  Wikidata IDs only (P61): {wikidata_only:,}'')\nprint(f''  Geni IDs only (P62): {geni_only:,}'') \nprint(f''  UUID identifiers (P63): {uuid_total:,}'')\nprint(f''  BOTH Wikidata + Geni: {both_wikidata_geni:,}'')\nprint(f''  No identifiers: {no_identifiers:,}'')\nprint()\nprint(''TOTALS:'')\nprint(f''  Total Wikidata IDs: {wikidata_total:,}'')\nprint(f''  Total Geni IDs: {geni_total:,}'')\nprint(f''  Entities with BOTH: {both_wikidata_geni:,}'')\nprint()\nprint(f''Overlap percentage: {both_wikidata_geni/wikidata_total*100:.1f}% of Wikidata entities also have Geni IDs'')\n\n# Show a few examples of entities with both\nprint()\nprint(''=== SAMPLE ENTITIES WITH BOTH IDENTIFIERS ==='')\nsamples = list(collection.find({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.P62'': {''$exists'': True}\n}).limit(5))\n\nfor i, entity in enumerate(samples, 1):\n    qid = entity[''qid'']\n    label = entity.get(''labels'', {}).get(''en'', ''No label'')\n    \n    # Get identifier values\n    wikidata_id = entity[''properties''][''P61''][0].get(''value'', '''') if entity[''properties''][''P61''] else ''''\n    geni_id = entity[''properties''][''P62''][0].get(''value'', '''') if entity[''properties''][''P62''] else ''''\n    \n    print(f''{i}. {qid} (\"\"{label}\"\"):'')\n    print(f''   Wikidata: {wikidata_id}'')\n    print(f''   Geni: {geni_id}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== COMPREHENSIVE PROPERTY CHECK ==='')\n\n# Manual property counting\nproperty_counts = Counter()\nfor entity in collection.find().limit(10000):  # Sample first 10k\n    properties = entity.get(''properties'', {})\n    for prop_id in properties.keys():\n        property_counts[prop_id] += 1\n\nprint(''Top properties in first 10,000 entities:'')\nfor prop, count in property_counts.most_common(15):\n    print(f''  {prop}: {count}'')\n\nprint()\nprint(''Specific identifier properties:'')\nfor prop in [''P44'', ''P43'', ''P60'', ''P61'', ''P62'', ''P63'']:\n    count = property_counts.get(prop, 0)\n    print(f''  {prop}: {count}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== IDENTIFIER OVERLAP ANALYSIS ==='')\nprint()\n\n# Count all identifier properties\nwikidata_count = 0\ngeni_count = 0\nuuid_count = 0 \nboth_wd_geni = 0\ntotal_processed = 0\n\nfor entity in collection.find():\n    total_processed += 1\n    if total_processed % 20000 == 0:\n        print(f''  Analyzed {total_processed:,} entities...'')\n    \n    properties = entity.get(''properties'', {})\n    has_wikidata = ''P61'' in properties\n    has_geni = ''P62'' in properties\n    has_uuid = ''P63'' in properties\n    \n    if has_wikidata:\n        wikidata_count += 1\n    if has_geni:\n        geni_count += 1\n    if has_uuid:\n        uuid_count += 1\n    if has_wikidata and has_geni:\n        both_wd_geni += 1\n\nprint(f''  Analyzed {total_processed:,} entities total'')\nprint()\n\nprint(''IDENTIFIER COUNTS:'')\nprint(f''  Wikidata IDs (P61): {wikidata_count:,}'')\nprint(f''  Geni IDs (P62): {geni_count:,}'') \nprint(f''  UUID identifiers (P63): {uuid_count:,}'')\nprint(f''  Entities with BOTH Wikidata + Geni: {both_wd_geni:,}'')\nprint()\n\nif wikidata_count > 0:\n    overlap_pct = both_wd_geni/wikidata_count*100\n    print(f''Overlap: {overlap_pct:.1f}% of Wikidata entities also have Geni IDs'')\n    print(f''That means {both_wd_geni:,} entities could be enhanced with Wikidata data!'')\n    print()\n\n# Show sample entities with both identifiers\nprint(''=== SAMPLE ENTITIES WITH BOTH IDENTIFIERS ==='')\nsamples_found = 0\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''P61'' in properties and ''P62'' in properties:\n        samples_found += 1\n        if samples_found <= 5:\n            qid = entity[''qid'']\n            label = entity.get(''labels'', {}).get(''en'', ''No label'')\n            \n            wikidata_id = properties[''P61''][0].get(''value'', '''') if properties[''P61''] else ''''\n            geni_id = properties[''P62''][0].get(''value'', '''') if properties[''P62''] else ''''\n            \n            print(f''{samples_found}. {qid} (\"\"{label}\"\"):'')\n            print(f''   Wikidata: {wikidata_id}'')\n            print(f''   Geni: {geni_id}'')\n        else:\n            break\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport re\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== ENTITIES WITH BOTH IDENTIFIERS + NON-LATIN LABELS ==='')\nprint()\n\ndef has_nonlatin_chars(text):\n    \"\"\"\"\"\"Check if text contains non-Latin characters\"\"\"\"\"\"\n    if not text:\n        return False\n    \n    # Check for common non-Latin scripts\n    # Japanese (Hiragana, Katakana, Kanji)\n    japanese = re.search(r''[\\u3040-\\u309F\\u30A0-\\u30FF\\u4E00-\\u9FFF]'', text)\n    # Chinese (CJK Unified Ideographs)\n    chinese = re.search(r''[\\u4E00-\\u9FFF]'', text)\n    # Korean (Hangul)\n    korean = re.search(r''[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F]'', text)\n    # Arabic\n    arabic = re.search(r''[\\u0600-\\u06FF\\u0750-\\u077F]'', text)\n    # Cyrillic\n    cyrillic = re.search(r''[\\u0400-\\u04FF]'', text)\n    # Greek\n    greek = re.search(r''[\\u0370-\\u03FF]'', text)\n    # Hebrew\n    hebrew = re.search(r''[\\u0590-\\u05FF]'', text)\n    \n    return bool(japanese or chinese or korean or arabic or cyrillic or greek or hebrew)\n\nnonlatin_count = 0\nsamples = []\ntotal_both = 0\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''P61'' in properties and ''P62'' in properties:\n        total_both += 1\n        \n        # Get English label\n        label = entity.get(''labels'', {}).get(''en'', '''')\n        \n        if has_nonlatin_chars(label):\n            nonlatin_count += 1\n            if len(samples) < 10:  # Collect first 10 samples\n                wikidata_id = properties[''P61''][0].get(''value'', '''') if properties[''P61''] else ''''\n                geni_id = properties[''P62''][0].get(''value'', '''') if properties[''P62''] else ''''\n                \n                samples.append({\n                    ''qid'': entity[''qid''],\n                    ''label'': label,\n                    ''wikidata'': wikidata_id,\n                    ''geni'': geni_id\n                })\n\nprint(f''Total entities with both Wikidata + Geni IDs: {total_both:,}'')\nprint(f''Entities with BOTH identifiers + non-Latin labels: {nonlatin_count:,}'')\nprint(f''Percentage with non-Latin labels: {nonlatin_count/total_both*100:.1f}%'')\nprint()\n\nif samples:\n    print(''=== SAMPLE ENTITIES WITH NON-LATIN LABELS ==='')\n    for i, sample in enumerate(samples, 1):\n        print(f''{i}. {sample[\"\"qid\"\"]} (\"\"{sample[\"\"label\"\"]}\"\":'')\n        print(f''   Wikidata: {sample[\"\"wikidata\"\"]}'')\n        print(f''   Geni: {sample[\"\"geni\"\"]}'')\n        print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport re\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\ndef has_nonlatin_chars(text):\n    if not text:\n        return False\n    \n    # Check for common non-Latin scripts\n    japanese = re.search(r''[\\u3040-\\u309F\\u30A0-\\u30FF\\u4E00-\\u9FFF]'', text)\n    chinese = re.search(r''[\\u4E00-\\u9FFF]'', text)\n    korean = re.search(r''[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F]'', text)\n    arabic = re.search(r''[\\u0600-\\u06FF\\u0750-\\u077F]'', text)\n    cyrillic = re.search(r''[\\u0400-\\u04FF]'', text)\n    greek = re.search(r''[\\u0370-\\u03FF]'', text)\n    hebrew = re.search(r''[\\u0590-\\u05FF]'', text)\n    \n    return bool(japanese or chinese or korean or arabic or cyrillic or greek or hebrew)\n\nprint(''=== FILTERING FOR NON-LATIN LABELS ==='')\nprint()\n\nnonlatin_entities = []\ntotal_both = 0\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''P61'' in properties and ''P62'' in properties:\n        total_both += 1\n        \n        label = entity.get(''labels'', {}).get(''en'', '''')\n        \n        if has_nonlatin_chars(label):\n            wikidata_id = properties[''P61''][0].get(''value'', '''') if properties[''P61''] else ''''\n            geni_id = properties[''P62''][0].get(''value'', '''') if properties[''P62''] else ''''\n            \n            nonlatin_entities.append({\n                ''qid'': entity[''qid''],\n                ''label'': label,\n                ''wikidata'': wikidata_id,\n                ''geni'': geni_id\n            })\n\nprint(f''Total entities with both Wikidata + Geni IDs: {total_both:,}'')\nprint(f''Entities with BOTH + non-Latin labels: {len(nonlatin_entities):,}'')\n\nif nonlatin_entities:\n    print()\n    print(''NON-LATIN ENTITIES (safe ASCII display):'')\n    for i, entity in enumerate(nonlatin_entities, 1):\n        print(f''{i}. {entity[\"\"qid\"\"]}'')\n        print(f''   Label length: {len(entity[\"\"label\"\"])} chars'')\n        print(f''   Label (first 50 chars): {repr(entity[\"\"label\"\"][:50])}'')\n        print(f''   Wikidata: {entity[\"\"wikidata\"\"]}'')\n        print(f''   Geni: {entity[\"\"geni\"\"]}'')\n        print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport re\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\ndef has_nonlatin_chars(text):\n    if not text:\n        return False\n    \n    japanese = re.search(r''[\\u3040-\\u309F\\u30A0-\\u30FF\\u4E00-\\u9FFF]'', text)\n    chinese = re.search(r''[\\u4E00-\\u9FFF]'', text)\n    korean = re.search(r''[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F]'', text)\n    arabic = re.search(r''[\\u0600-\\u06FF\\u0750-\\u077F]'', text)\n    cyrillic = re.search(r''[\\u0400-\\u04FF]'', text)\n    greek = re.search(r''[\\u0370-\\u03FF]'', text)\n    hebrew = re.search(r''[\\u0590-\\u05FF]'', text)\n    \n    return bool(japanese or chinese or korean or arabic or cyrillic or greek or hebrew)\n\nprint(''=== NON-LATIN LABEL ANALYSIS ==='')\n\nnonlatin_qids = []\ntotal_both = 0\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''P61'' in properties and ''P62'' in properties:\n        total_both += 1\n        \n        label = entity.get(''labels'', {}).get(''en'', '''')\n        \n        if has_nonlatin_chars(label):\n            wikidata_id = properties[''P61''][0].get(''value'', '''') if properties[''P61''] else ''''\n            geni_id = properties[''P62''][0].get(''value'', '''') if properties[''P62''] else ''''\n            \n            nonlatin_qids.append({\n                ''qid'': entity[''qid''],\n                ''wikidata'': wikidata_id,\n                ''geni'': geni_id,\n                ''has_japanese'': bool(re.search(r''[\\u3040-\\u309F\\u30A0-\\u30FF\\u4E00-\\u9FFF]'', label)),\n                ''has_chinese'': bool(re.search(r''[\\u4E00-\\u9FFF]'', label)),\n                ''has_korean'': bool(re.search(r''[\\uAC00-\\uD7AF]'', label)),\n                ''has_arabic'': bool(re.search(r''[\\u0600-\\u06FF]'', label)),\n                ''has_cyrillic'': bool(re.search(r''[\\u0400-\\u04FF]'', label))\n            })\n\nprint(f''Total entities with both identifiers: {total_both:,}'')\nprint(f''Entities with non-Latin labels: {len(nonlatin_qids):,}'')\nprint()\n\nif nonlatin_qids:\n    for entity in nonlatin_qids:\n        print(f''QID: {entity[\"\"qid\"\"]}'')\n        print(f''Wikidata: {entity[\"\"wikidata\"\"]}'')\n        print(f''Geni: {entity[\"\"geni\"\"]}'')\n        \n        scripts = []\n        if entity[''has_japanese'']: scripts.append(''Japanese'')\n        if entity[''has_chinese'']: scripts.append(''Chinese'')  \n        if entity[''has_korean'']: scripts.append(''Korean'')\n        if entity[''has_arabic'']: scripts.append(''Arabic'')\n        if entity[''has_cyrillic'']: scripts.append(''Cyrillic'')\n        \n        print(f''Scripts detected: {'', ''.join(scripts) if scripts else ''Unknown''}'')\n        print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find and update Q29136\nentity = collection.find_one({''qid'': ''Q29136''})\nif entity:\n    print(f''Found entity Q29136'')\n    current_label = entity.get(''labels'', {}).get(''en'', ''No label'')\n    print(f''Current English label: \"\"{current_label}\"\"'')\n    \n    # Update the English label to ''Zarathustra''\n    result = collection.update_one(\n        {''qid'': ''Q29136''},\n        {''$set'': {''labels.en'': ''Zarathustra''}}\n    )\n    \n    if result.modified_count > 0:\n        print(''Successfully updated English label to \"\"Zarathustra\"\"'')\n    else:\n        print(''Failed to update label'')\nelse:\n    print(''Entity Q29136 not found'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find and update Q29136\nentity = collection.find_one({''qid'': ''Q29136''})\nif entity:\n    print(''Found entity Q29136'')\n    print(''Current label contains Arabic characters (not displayable)'')\n    \n    # Update the English label to ''Zarathustra''\n    result = collection.update_one(\n        {''qid'': ''Q29136''},\n        {''$set'': {''labels.en'': ''Zarathustra''}}\n    )\n    \n    if result.modified_count > 0:\n        print(''Successfully updated English label to \"\"Zarathustra\"\"'')\n        \n        # Verify the update\n        updated_entity = collection.find_one({''qid'': ''Q29136''})\n        new_label = updated_entity.get(''labels'', {}).get(''en'', ''No label'')\n        print(f''Verified new label: \"\"{new_label}\"\"'')\n    else:\n        print(''Failed to update label'')\nelse:\n    print(''Entity Q29136 not found'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find and update Q29136\nentity = collection.find_one({''qid'': ''Q29136''})\nif entity:\n    print(''Found entity Q29136'')\n    print(''Current label contains Arabic characters (not displayable)'')\n    \n    # Update the English label to ''Zarathustra''\n    result = collection.update_one(\n        {''qid'': ''Q29136''},\n        {''$set'': {''labels.en'': ''Zarathustra''}}\n    )\n    \n    if result.modified_count > 0:\n        print(''Successfully updated English label to \"\"Zarathustra\"\"'')\n        \n        # Verify the update\n        updated_entity = collection.find_one({''qid'': ''Q29136''})\n        new_label = updated_entity.get(''labels'', {}).get(''en'', ''No label'')\n        print(f''Verified new label: \"\"{new_label}\"\"'')\n    else:\n        print(''Failed to update label'')\nelse:\n    print(''Entity Q29136 not found'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING FOR DUPLICATE P62 (GENI ID) VALUES ==='')\nprint()\n\n# Track Geni IDs and which entities have them\ngeni_id_map = defaultdict(list)\ntotal_entities_with_p62 = 0\n\nfor entity in collection.find({''properties.P62'': {''$exists'': True}}):\n    total_entities_with_p62 += 1\n    if total_entities_with_p62 % 5000 == 0:\n        print(f''  Processed {total_entities_with_p62:,} entities with P62...'')\n    \n    qid = entity[''qid'']\n    label = entity.get(''labels'', {}).get(''en'', ''No label'')\n    p62_claims = entity.get(''properties'', {}).get(''P62'', [])\n    \n    for claim in p62_claims:\n        geni_id = claim.get(''value'', '''')\n        if geni_id:\n            geni_id_map[geni_id].append({\n                ''qid'': qid,\n                ''label'': label\n            })\n\nprint(f''  Processed {total_entities_with_p62:,} entities with P62 total'')\nprint()\n\n# Find duplicates\nduplicates = {geni_id: entities for geni_id, entities in geni_id_map.items() if len(entities) > 1}\n\nprint(f''Total unique Geni IDs: {len(geni_id_map):,}'')\nprint(f''Geni IDs with duplicates: {len(duplicates):,}'')\nprint()\n\nif duplicates:\n    print(''=== DUPLICATE GENI IDs ==='')\n    duplicate_count = 0\n    for geni_id, entities in sorted(duplicates.items(), key=lambda x: len(x[1]), reverse=True):\n        duplicate_count += 1\n        if duplicate_count <= 10:  # Show first 10 duplicates\n            print(f''Geni ID {geni_id}: {len(entities)} entities'')\n            for entity in entities:\n                print(f''  {entity[\"\"qid\"\"]}: \"\"{entity[\"\"label\"\"]}\"\"'')\n            print()\n        \n        if duplicate_count == 10:\n            print(f''... and {len(duplicates) - 10} more duplicate Geni IDs'')\n            break\n    \n    # Statistics\n    total_duplicate_entities = sum(len(entities) for entities in duplicates.values())\n    max_duplicates = max(len(entities) for entities in duplicates.values())\n    \n    print(f''Total entities involved in duplicates: {total_duplicate_entities:,}'')\n    print(f''Largest duplicate group size: {max_duplicates} entities'')\nelse:\n    print(''No duplicate Geni IDs found - all are unique!'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict, Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DEBUGGING P62 EXISTENCE ==='')\nprint()\n\n# Check if P62 exists at all\np62_direct_count = collection.count_documents({''properties.P62'': {''$exists'': True}})\nprint(f''Direct MongoDB count of P62 entities: {p62_direct_count:,}'')\n\n# Manual check\nproperty_counts = Counter()\np62_entities = []\nsample_count = 0\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    for prop_id in properties.keys():\n        property_counts[prop_id] += 1\n    \n    if ''P62'' in properties:\n        p62_entities.append(entity)\n        sample_count += 1\n        if sample_count >= 5:  # Get first 5 samples\n            break\n\nprint(f''Manual count of P62 entities: {property_counts.get(\"\"P62\"\", 0):,}'')\nprint()\n\nif p62_entities:\n    print(''Sample P62 entities:'')\n    for entity in p62_entities:\n        qid = entity[''qid'']\n        label = entity.get(''labels'', {}).get(''en'', ''No label'')\n        p62_claims = entity[''properties''][''P62'']\n        print(f''{qid} (\"\"{label}\"\"): {len(p62_claims)} P62 claims'')\n        for claim in p62_claims:\n            print(f''  Value: {claim.get(\"\"value\"\")}'')\nelse:\n    print(''No P62 entities found in sample'')\n\nprint()\nprint(''Top 10 properties:'')\nfor prop, count in property_counts.most_common(10):\n    print(f''  {prop}: {count:,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING FOR DUPLICATE P62 VALUES ==='')\nprint()\n\n# Track Geni IDs manually\ngeni_id_map = defaultdict(list)\ninternal_duplicates = 0\ntotal_entities_checked = 0\n\nfor entity in collection.find():\n    total_entities_checked += 1\n    if total_entities_checked % 10000 == 0:\n        print(f''  Checked {total_entities_checked:,} entities...'')\n    \n    properties = entity.get(''properties'', {})\n    if ''P62'' in properties:\n        qid = entity[''qid'']\n        label = entity.get(''labels'', {}).get(''en'', ''No label'')\n        p62_claims = properties[''P62'']\n        \n        # Check for internal duplicates (same entity, duplicate claims)\n        claim_values = [claim.get(''value'', '''') for claim in p62_claims]\n        unique_values = set(claim_values)\n        \n        if len(claim_values) > len(unique_values):\n            internal_duplicates += 1\n        \n        # Track unique Geni IDs across entities\n        for value in unique_values:\n            if value:\n                geni_id_map[value].append({\n                    ''qid'': qid,\n                    ''label'': label\n                })\n\nprint(f''  Checked {total_entities_checked:,} entities total'')\nprint()\n\n# Find cross-entity duplicates\ncross_entity_duplicates = {geni_id: entities for geni_id, entities in geni_id_map.items() if len(entities) > 1}\n\nprint(f''Entities with internal duplicate P62 claims: {internal_duplicates:,}'')\nprint(f''Total unique Geni IDs: {len(geni_id_map):,}'')\nprint(f''Geni IDs shared across multiple entities: {len(cross_entity_duplicates):,}'')\nprint()\n\nif cross_entity_duplicates:\n    print(''=== CROSS-ENTITY DUPLICATE GENI IDs ==='')\n    for i, (geni_id, entities) in enumerate(sorted(cross_entity_duplicates.items(), key=lambda x: len(x[1]), reverse=True)):\n        if i >= 10:  # Show first 10\n            break\n        print(f''Geni ID {geni_id}: {len(entities)} entities'')\n        for entity in entities:\n            print(f''  {entity[\"\"qid\"\"]}: \"\"{entity[\"\"label\"\"]}\"\"'')\n        print()\n\nif internal_duplicates > 0:\n    print(f''WARNING: {internal_duplicates:,} entities have duplicate P62 claims within the same entity'')\n    print(''This suggests the migration created duplicate claims'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING FOR DUPLICATE P61 (WIKIDATA QID) VALUES ==='')\nprint()\n\n# Track Wikidata QIDs manually\nwikidata_id_map = defaultdict(list)\ninternal_duplicates = 0\ntotal_entities_checked = 0\n\nfor entity in collection.find():\n    total_entities_checked += 1\n    if total_entities_checked % 10000 == 0:\n        print(f''  Checked {total_entities_checked:,} entities...'')\n    \n    properties = entity.get(''properties'', {})\n    if ''P61'' in properties:\n        qid = entity[''qid'']\n        label = entity.get(''labels'', {}).get(''en'', ''No label'')\n        p61_claims = properties[''P61'']\n        \n        # Check for internal duplicates (same entity, duplicate claims)\n        claim_values = [claim.get(''value'', '''') for claim in p61_claims]\n        unique_values = set(claim_values)\n        \n        if len(claim_values) > len(unique_values):\n            internal_duplicates += 1\n        \n        # Track unique Wikidata QIDs across entities\n        for value in unique_values:\n            if value:\n                wikidata_id_map[value].append({\n                    ''qid'': qid,\n                    ''label'': label\n                })\n\nprint(f''  Checked {total_entities_checked:,} entities total'')\nprint()\n\n# Find cross-entity duplicates\ncross_entity_duplicates = {wd_qid: entities for wd_qid, entities in wikidata_id_map.items() if len(entities) > 1}\n\nprint(f''Entities with internal duplicate P61 claims: {internal_duplicates:,}'')\nprint(f''Total unique Wikidata QIDs: {len(wikidata_id_map):,}'')\nprint(f''Wikidata QIDs shared across multiple entities: {len(cross_entity_duplicates):,}'')\nprint()\n\nif cross_entity_duplicates:\n    print(''=== CROSS-ENTITY DUPLICATE WIKIDATA QIDs ==='')\n    for i, (wd_qid, entities) in enumerate(sorted(cross_entity_duplicates.items(), key=lambda x: len(x[1]), reverse=True)):\n        if i >= 10:  # Show first 10\n            break\n        print(f''Wikidata QID {wd_qid}: {len(entities)} entities'')\n        for entity in entities:\n            print(f''  {entity[\"\"qid\"\"]}: \"\"{entity[\"\"label\"\"]}\"\"'')\n        print()\n\nif internal_duplicates > 0:\n    print(f''WARNING: {internal_duplicates:,} entities have duplicate P61 claims within the same entity'')\n    print(''This suggests the migration created duplicate claims'')\n\n# Statistics\nif cross_entity_duplicates:\n    total_duplicate_entities = sum(len(entities) for entities in cross_entity_duplicates.values())\n    max_duplicates = max(len(entities) for entities in cross_entity_duplicates.values())\n    \n    print()\n    print(''=== DUPLICATE STATISTICS ==='')\n    print(f''Total entities involved in Wikidata duplicates: {total_duplicate_entities:,}'')\n    print(f''Largest duplicate group size: {max_duplicates} entities'')\n    \n    # Show distribution\n    size_counts = defaultdict(int)\n    for entities in cross_entity_duplicates.values():\n        size_counts[len(entities)] += 1\n    \n    print()\n    print(''Duplicate group sizes:'')\n    for size in sorted(size_counts.keys(), reverse=True):\n        print(f''  {size} entities: {size_counts[size]:,} Wikidata QIDs'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING FOR DUPLICATE P63 (UUID) VALUES ==='')\nprint()\n\n# Track UUIDs manually\nuuid_id_map = defaultdict(list)\ninternal_duplicates = 0\ntotal_entities_checked = 0\n\nfor entity in collection.find():\n    total_entities_checked += 1\n    if total_entities_checked % 10000 == 0:\n        print(f''  Checked {total_entities_checked:,} entities...'')\n    \n    properties = entity.get(''properties'', {})\n    if ''P63'' in properties:\n        qid = entity[''qid'']\n        label = entity.get(''labels'', {}).get(''en'', ''No label'')\n        p63_claims = properties[''P63'']\n        \n        # Check for internal duplicates (same entity, duplicate claims)\n        claim_values = [claim.get(''value'', '''') for claim in p63_claims]\n        unique_values = set(claim_values)\n        \n        if len(claim_values) > len(unique_values):\n            internal_duplicates += 1\n        \n        # Track unique UUIDs across entities\n        for value in unique_values:\n            if value:\n                uuid_id_map[value].append({\n                    ''qid'': qid,\n                    ''label'': label\n                })\n\nprint(f''  Checked {total_entities_checked:,} entities total'')\nprint()\n\n# Find cross-entity duplicates\ncross_entity_duplicates = {uuid_id: entities for uuid_id, entities in uuid_id_map.items() if len(entities) > 1}\n\nprint(f''Entities with internal duplicate P63 claims: {internal_duplicates:,}'')\nprint(f''Total unique UUIDs: {len(uuid_id_map):,}'')\nprint(f''UUIDs shared across multiple entities: {len(cross_entity_duplicates):,}'')\nprint()\n\nif cross_entity_duplicates:\n    print(''=== CROSS-ENTITY DUPLICATE UUIDs ==='')\n    for i, (uuid_id, entities) in enumerate(sorted(cross_entity_duplicates.items(), key=lambda x: len(x[1]), reverse=True)):\n        if i >= 10:  # Show first 10\n            break\n        print(f''UUID {uuid_id}: {len(entities)} entities'')\n        for entity in entities:\n            print(f''  {entity[\"\"qid\"\"]}: \"\"{entity[\"\"label\"\"]}\"\"'')\n        print()\n\nif internal_duplicates > 0:\n    print(f''WARNING: {internal_duplicates:,} entities have duplicate P63 claims within the same entity'')\n    print(''This suggests the migration created duplicate claims'')\n\n# Statistics\nif cross_entity_duplicates:\n    total_duplicate_entities = sum(len(entities) for entities in cross_entity_duplicates.values())\n    max_duplicates = max(len(entities) for entities in cross_entity_duplicates.values())\n    \n    print()\n    print(''=== DUPLICATE STATISTICS ==='')\n    print(f''Total entities involved in UUID duplicates: {total_duplicate_entities:,}'')\n    print(f''Largest duplicate group size: {max_duplicates} entities'')\n    \n    # Show distribution\n    size_counts = defaultdict(int)\n    for entities in cross_entity_duplicates.values():\n        size_counts[len(entities)] += 1\n    \n    print()\n    print(''Duplicate group sizes:'')\n    for size in sorted(size_counts.keys(), reverse=True):\n        print(f''  {size} entities: {size_counts[size]:,} UUIDs'')\nelse:\n    print(''No cross-entity UUID duplicates found - all UUIDs are unique!'')\n\nclient.close()\n\")",
      "Bash(mongodump:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/entity_merger.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/efficient_entity_merger.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DUPLICATE VERIFICATION ==='')\nprint()\n\nfor prop in [''P61'', ''P62'', ''P63'']:\n    print(f''Checking {prop} duplicates...'')\n    \n    # Count entities with this property\n    total_with_prop = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    \n    # Manual duplicate detection\n    prop_values = defaultdict(list)\n    checked = 0\n    \n    for entity in collection.find({f''properties.{prop}'': {''$exists'': True}}):\n        checked += 1\n        qid = entity[''qid'']\n        claims = entity[''properties''][prop]\n        \n        # Get unique values from claims\n        values = set()\n        for claim in claims:\n            value = claim.get(''value'', '''')\n            if value:\n                values.add(value)\n        \n        # Track which entities have each value\n        for value in values:\n            prop_values[value].append(qid)\n    \n    # Find duplicates\n    duplicates = {value: qids for value, qids in prop_values.items() if len(qids) > 1}\n    \n    print(f''  Total entities with {prop}: {total_with_prop:,}'')\n    print(f''  Unique {prop} values: {len(prop_values):,}'')\n    print(f''  {prop} values with duplicates: {len(duplicates):,}'')\n    \n    if duplicates:\n        total_dup_entities = sum(len(qids) for qids in duplicates.values())\n        print(f''  Total entities in duplicate groups: {total_dup_entities:,}'')\n        \n        # Show first few examples\n        print(f''  Sample duplicates:'')\n        for i, (value, qids) in enumerate(list(duplicates.items())[:3]):\n            print(f''    {value}: {qids[:5]} ({len(qids)} total)'')\n        \n        if len(duplicates) > 3:\n            print(f''    ... and {len(duplicates) - 3} more'')\n    else:\n        print(f''  SUCCESS: No duplicates found!'')\n    print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== REFERENCE UPDATE VERIFICATION ==='')\nprint()\n\n# First, get all redirect QIDs and their targets\nprint(''Getting all redirects...'')\nredirects = {}  # redirect_qid -> target_qid\nredirect_count = 0\n\nfor entity in collection.find({''properties.redirect'': {''$exists'': True}}):\n    redirect_count += 1\n    redirect_qid = entity[''qid'']\n    redirect_claims = entity[''properties''][''redirect'']\n    \n    for claim in redirect_claims:\n        target_qid = claim.get(''value'', '''')\n        if target_qid:\n            redirects[redirect_qid] = target_qid\n            break\n\nprint(f''Found {redirect_count:,} redirect entities'')\nprint(f''Redirect mappings: {len(redirects):,}'')\nprint()\n\n# Now check if any properties still reference redirect QIDs\nprint(''Scanning all entities for references to redirect QIDs...'')\nbad_references = []\ntotal_checked = 0\n\nfor entity in collection.find():\n    total_checked += 1\n    if total_checked % 20000 == 0:\n        print(f''  Checked {total_checked:,} entities...'')\n    \n    qid = entity[''qid'']\n    properties = entity.get(''properties'', {})\n    \n    # Skip redirect entities themselves\n    if ''redirect'' in properties:\n        continue\n    \n    # Check all property values for references to redirect QIDs\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            \n            # Check different value types for QID references\n            referenced_qid = None\n            if isinstance(value, str) and value.startswith(''Q''):\n                referenced_qid = value\n            elif isinstance(value, dict) and value.get(''id'', '''').startswith(''Q''):\n                referenced_qid = value[''id'']\n            \n            # If this references a redirect QID, that''s a problem\n            if referenced_qid and referenced_qid in redirects:\n                bad_references.append({\n                    ''entity'': qid,\n                    ''property'': prop_id,\n                    ''references_redirect'': referenced_qid,\n                    ''should_be'': redirects[referenced_qid],\n                    ''claim'': claim\n                })\n\nprint(f''  Checked {total_checked:,} entities total'')\nprint()\n\nprint(''=== RESULTS ==='')\nif bad_references:\n    print(f''ERROR: Found {len(bad_references)} bad references still pointing to redirect QIDs!'')\n    print()\n    print(''Sample bad references:'')\n    for i, ref in enumerate(bad_references[:10]):\n        print(f''  {i+1}. Entity {ref[\"\"entity\"\"]} property {ref[\"\"property\"\"]} -> {ref[\"\"references_redirect\"\"]} (should be {ref[\"\"should_be\"\"]})'')\n    \n    if len(bad_references) > 10:\n        print(f''  ... and {len(bad_references) - 10} more bad references'')\nelse:\n    print(''SUCCESS: All references properly updated!'')\n    print(''No entities are referencing redirect QIDs'')\n\nprint()\nprint(''=== SUMMARY ==='')\nprint(f''Total entities scanned: {total_checked:,}'')\nprint(f''Redirect entities found: {redirect_count:,}'')\nprint(f''Bad references found: {len(bad_references):,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== REDIRECT ENTITY INVESTIGATION ==='')\nprint()\n\n# Check total entity count\ntotal_entities = collection.count_documents({})\nprint(f''Total entities in database: {total_entities:,}'')\nprint()\n\n# Look for redirect property with different query approaches\nredirect_count_1 = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nprint(f''Entities with properties.redirect: {redirect_count_1:,}'')\n\n# Check for any entities that might have redirect in different structure\nsample_entities = list(collection.find().limit(10))\nprint()\nprint(''Sample entity structures:'')\nfor i, entity in enumerate(sample_entities[:3]):\n    qid = entity.get(''qid'', ''NO_QID'')\n    props = list(entity.get(''properties'', {}).keys())[:5]\n    print(f''  {i+1}. {qid}: properties = {props}'')\n\nprint()\n\n# Check if we can find any entities that were supposed to be redirects\n# Look for entities that might have been created as redirects but stored differently\nprint(''Searching for entities with minimal properties (potential redirects)...'')\nminimal_entities = 0\nredirect_like_entities = []\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    labels = entity.get(''labels'', {})\n    descriptions = entity.get(''descriptions'', {})\n    \n    # Check if entity has very few properties (might be redirect)\n    if (len(properties) <= 1 and \n        len(labels) == 0 and \n        len(descriptions) == 0):\n        minimal_entities += 1\n        if len(redirect_like_entities) < 5:\n            redirect_like_entities.append({\n                ''qid'': entity[''qid''],\n                ''properties'': properties,\n                ''labels'': labels,\n                ''descriptions'': descriptions\n            })\n\nprint(f''Found {minimal_entities:,} entities with minimal data (potential redirects)'')\n\nif redirect_like_entities:\n    print()\n    print(''Sample minimal entities:'')\n    for entity in redirect_like_entities:\n        print(f''  {entity[\"\"qid\"\"]}: {entity[\"\"properties\"\"]}'')\n\n# Also check database size before/after to see if merging actually happened\nprint()\nprint(''=== DATABASE STATISTICS ==='')\n\n# Count entities by property presence\np61_count = collection.count_documents({''properties.P61'': {''$exists'': True}})\np62_count = collection.count_documents({''properties.P62'': {''$exists'': True}})\np63_count = collection.count_documents({''properties.P63'': {''$exists'': True}})\n\nprint(f''Entities with P61: {p61_count:,}'')\nprint(f''Entities with P62: {p62_count:,}'')\nprint(f''Entities with P63: {p63_count:,}'')\n\n# Check if database size changed\nprint(f''Current total entities: {total_entities:,}'')\nprint(''Expected reduction from merges: ~35,466 entities should be redirects'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== INVESTIGATING REDIRECT CREATION ISSUE ==='')\nprint()\n\n# Let''s examine the empty entities more closely\nempty_entities = list(collection.find({''properties'': {}}).limit(10))\nprint(f''Entities with completely empty properties: {len(empty_entities)}'')\n\nif empty_entities:\n    print(''Sample empty entities:'')\n    for entity in empty_entities[:5]:\n        qid = entity.get(''qid'')\n        print(f''  {qid}: {entity}'')\n\nprint()\n\n# Check if the redirect property was created with a different structure\n# Maybe it''s not nested under properties?\nredirect_samples = []\nfor entity in collection.find().limit(1000):\n    if ''redirect'' in entity:  # Check at root level\n        redirect_samples.append(entity)\n    elif entity.get(''properties'', {}) and ''redirect'' in str(entity[''properties'']):  # String search\n        redirect_samples.append(entity)\n    \n    if len(redirect_samples) >= 5:\n        break\n\nprint(f''Found {len(redirect_samples)} entities with redirect at any level'')\nif redirect_samples:\n    print(''Sample redirect entities:'')\n    for entity in redirect_samples:\n        print(f''  {entity.get(\"\"qid\"\")}: {entity}'')\n\nprint()\n\n# Let''s also check what the merger statistics showed vs reality\nprint(''=== MERGER STATISTICS REVIEW ==='')\nprint(''The merger reported:'')\nprint(''- 35,466 total merges'')\nprint(''- 35,466 redirects created'') \nprint(''- 10,075 references updated'')\nprint()\nprint(''But we observe:'')\nprint(''- 145,396 total entities (no reduction)'')\nprint(''- 0 entities with properties.redirect'')\nprint(''- 73,141 entities with empty/minimal properties'')\nprint(''- 0 entities with P61/P62/P63 (all duplicates gone)'')\n\nprint()\nprint(''This suggests the merge operations worked (duplicates eliminated)'')\nprint(''but redirect creation may have failed or used wrong structure.'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/fix_redirects.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== REDIRECT VERIFICATION ==='')\n\n# Count redirects\ntotal_redirects = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nprint(f''Total redirect entities: {total_redirects:,}'')\n\n# Count empty entities remaining  \nempty_entities = collection.count_documents({\n    ''properties'': {},\n    ''labels'': {},\n    ''descriptions'': {},\n    ''aliases'': {}\n})\nprint(f''Remaining empty entities: {empty_entities:,}'')\n\n# Verify no bad references\nprint()\nprint(''Checking for bad references to redirect entities...'')\n\nredirects = {}\nfor entity in collection.find({''properties.redirect'': {''$exists'': True}}):\n    redirect_qid = entity[''qid'']\n    target_qid = entity[''properties''][''redirect''][0][''value'']\n    redirects[redirect_qid] = target_qid\n\nprint(f''Loaded {len(redirects):,} redirect mappings'')\n\n# Check for bad references\nbad_refs = 0\nchecked = 0\n\nfor entity in collection.find():\n    checked += 1\n    if checked % 30000 == 0:\n        print(f''  Checked {checked:,} entities...'')\n    \n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n        \n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            \n            referenced_qid = None\n            if isinstance(value, str) and value.startswith(''Q''):\n                referenced_qid = value\n            elif isinstance(value, dict) and value.get(''id'', '''').startswith(''Q''):\n                referenced_qid = value[''id'']\n            \n            if referenced_qid and referenced_qid in redirects:\n                bad_refs += 1\n                if bad_refs <= 5:  # Show first 5\n                    print(f''  BAD: {entity[\"\"qid\"\"]} prop {prop_id} -> {referenced_qid} (should be {redirects[referenced_qid]})'')\n\nprint(f''  Checked {checked:,} entities total'')\nprint(f''Bad references found: {bad_refs:,}'')\n\nif bad_refs == 0:\n    print(''SUCCESS: All references properly point to targets, not redirects!'')\nelse:\n    print(''Some references still point to redirect entities'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DETAILED REDIRECT INVESTIGATION ==='')\n\n# Check various ways redirects might exist\nprint(''Searching for redirect property in different structures...'')\n\nredirect_in_properties = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nredirect_at_root = collection.count_documents({''redirect'': {''$exists'': True}})\n\nprint(f''properties.redirect: {redirect_in_properties:,}'')\nprint(f''redirect (root level): {redirect_at_root:,}'')\n\n# Check a few sample entities that were supposed to be redirects\nsample_qids = [''Q16401'', ''Q16406'', ''Q16420'']\nprint()\nprint(''Sample entities that should be redirects:'')\nfor qid in sample_qids:\n    entity = collection.find_one({''qid'': qid})\n    if entity:\n        print(f''{qid}: {entity}'')\n    else:\n        print(f''{qid}: NOT FOUND'')\n\n# Check total entity counts\ntotal = collection.count_documents({})\nempty = collection.count_documents({''properties'': {}})\n\nprint(f'''')\nprint(f''Total entities: {total:,}'')\nprint(f''Empty properties: {empty:,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL COMPLETE VERIFICATION ==='')\nprint()\n\n# Count redirects correctly\nredirects_found = 0\nredirect_mappings = {}\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        redirects_found += 1\n        redirect_qid = entity[''qid'']\n        target_qid = properties[''redirect''][0][''value'']\n        redirect_mappings[redirect_qid] = target_qid\n\nprint(f''✓ Total redirect entities found: {redirects_found:,}'')\nprint(f''✓ Redirect mappings loaded: {len(redirect_mappings):,}'')\n\n# Check for bad references\nprint()\nprint(''Verifying all references point to targets, not redirects...'')\n\nbad_references = 0\ntotal_checked = 0\n\nfor entity in collection.find():\n    total_checked += 1\n    if total_checked % 30000 == 0:\n        print(f''  Checked {total_checked:,} entities...'')\n    \n    # Skip redirect entities themselves\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    \n    # Check all property references\n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            \n            referenced_qid = None\n            if isinstance(value, str) and value.startswith(''Q''):\n                referenced_qid = value\n            elif isinstance(value, dict) and value.get(''id'', '''').startswith(''Q''):\n                referenced_qid = value[''id'']\n            \n            if referenced_qid and referenced_qid in redirect_mappings:\n                bad_references += 1\n                if bad_references <= 3:\n                    print(f''  BAD REF: {entity[\"\"qid\"\"]} prop {prop_id} points to redirect {referenced_qid} instead of target {redirect_mappings[referenced_qid]}'')\n\nprint(f''  Checked {total_checked:,} entities'')\nprint()\n\n# Final status\nprint(''=== FINAL STATUS ==='')\nprint(f''✓ Total entities in database: {total_checked:,}'')\nprint(f''✓ Redirect entities: {redirects_found:,}'')\nprint(f''✓ Active entities: {total_checked - redirects_found:,}'')\nprint(f''✓ Bad references to redirects: {bad_references:,}'')\n\nif bad_references == 0:\n    print()\n    print(''🎉 SUCCESS: Entity merger and redirect fix COMPLETELY SUCCESSFUL!'')\n    print(''   - All duplicates eliminated'')\n    print(''   - All properties merged to targets'') \n    print(''   - All references point to targets'')\n    print(''   - All redirect entities properly created'')\nelse:\n    print(f''⚠️  WARNING: {bad_references:,} references still point to redirects'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL COMPLETE VERIFICATION ==='')\nprint()\n\n# Count redirects correctly\nredirects_found = 0\nredirect_mappings = {}\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        redirects_found += 1\n        redirect_qid = entity[''qid'']\n        target_qid = properties[''redirect''][0][''value'']\n        redirect_mappings[redirect_qid] = target_qid\n\nprint(f''Total redirect entities found: {redirects_found:,}'')\nprint(f''Redirect mappings loaded: {len(redirect_mappings):,}'')\n\n# Check for bad references\nprint()\nprint(''Verifying all references point to targets, not redirects...'')\n\nbad_references = 0\ntotal_checked = 0\n\nfor entity in collection.find():\n    total_checked += 1\n    if total_checked % 30000 == 0:\n        print(f''  Checked {total_checked:,} entities...'')\n    \n    # Skip redirect entities themselves\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    \n    # Check all property references\n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            \n            referenced_qid = None\n            if isinstance(value, str) and value.startswith(''Q''):\n                referenced_qid = value\n            elif isinstance(value, dict) and value.get(''id'', '''').startswith(''Q''):\n                referenced_qid = value[''id'']\n            \n            if referenced_qid and referenced_qid in redirect_mappings:\n                bad_references += 1\n                if bad_references <= 3:\n                    print(f''  BAD REF: {entity[\"\"qid\"\"]} prop {prop_id} points to redirect {referenced_qid} instead of target {redirect_mappings[referenced_qid]}'')\n\nprint(f''  Checked {total_checked:,} entities'')\nprint()\n\n# Final status\nprint(''=== FINAL STATUS ==='')\nprint(f''Total entities in database: {total_checked:,}'')\nprint(f''Redirect entities: {redirects_found:,}'')\nprint(f''Active entities: {total_checked - redirects_found:,}'')\nprint(f''Bad references to redirects: {bad_references:,}'')\n\nif bad_references == 0:\n    print()\n    print(''SUCCESS: Entity merger and redirect fix COMPLETELY SUCCESSFUL!'')\n    print(''   - All duplicates eliminated'')\n    print(''   - All properties merged to targets'') \n    print(''   - All references point to targets'')\n    print(''   - All redirect entities properly created'')\nelse:\n    print(f''WARNING: {bad_references:,} references still point to redirects'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/fix_bad_references.py)",
      "Bash(mongorestore --drop mongodb_backup_pre_merge/)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DATABASE RESTORE VERIFICATION ==='')\nprint()\n\ntotal = collection.count_documents({})\nprint(f''Total entities: {total:,}'')\n\n# Check for duplicates again\np61_count = collection.count_documents({''properties.P61'': {''$exists'': True}})\np62_count = collection.count_documents({''properties.P62'': {''$exists'': True}})\np63_count = collection.count_documents({''properties.P63'': {''$exists'': True}})\n\nprint(f''P61 entities: {p61_count:,}'')\nprint(f''P62 entities: {p62_count:,}'')\nprint(f''P63 entities: {p63_count:,}'')\n\n# Check for any redirects (should be 0 after restore)\nredirects = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nprint(f''Redirect entities: {redirects:,}'')\n\n# Sample a few entities to verify structure\nprint()\nprint(''Sample entity with multiple identifier properties:'')\nsample = collection.find_one({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.P62'': {''$exists'': True}\n})\n\nif sample:\n    qid = sample[''qid'']\n    p61_claims = sample[''properties''][''P61'']\n    p62_claims = sample[''properties''][''P62'']\n    print(f''{qid}:'')\n    print(f''  P61 claims: {len(p61_claims)} - {[c.get(\"\"value\"\") for c in p61_claims]}'')\n    print(f''  P62 claims: {len(p62_claims)} - {[c.get(\"\"value\"\") for c in p62_claims]}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== IDENTIFIER PROPERTIES IN RESTORED DATABASE ==='')\n\n# Check original identifier properties\np44_count = collection.count_documents({''properties.P44'': {''$exists'': True}})\np43_count = collection.count_documents({''properties.P43'': {''$exists'': True}})\np60_count = collection.count_documents({''properties.P60'': {''$exists'': True}})\n\nprint(f''P44 (old Wikidata): {p44_count:,} entities'')\nprint(f''P43 (old Geni): {p43_count:,} entities'')\nprint(f''P60 (old UUID): {p60_count:,} entities'')\n\n# Check for duplicate patterns\nprint()\nprint(''=== CHECKING FOR DUPLICATES IN ORIGINAL DATA ==='')\n\n# Sample P44 duplicates\np44_values = Counter()\nfor entity in collection.find({''properties.P44'': {''$exists'': True}}).limit(10000):\n    for claim in entity[''properties''][''P44'']:\n        value = claim.get(''value'', '''')\n        if value:\n            p44_values[value] += 1\n\nduplicates = {v: c for v, c in p44_values.items() if c > 1}\nprint(f''P44 duplicates in sample: {len(duplicates)} values appear multiple times'')\nif duplicates:\n    print(f''Sample: {list(duplicates.items())[:3]}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== ANALYZING RESTORED DATABASE PROPERTIES ==='')\n\n# Get property counts  \nproperty_counts = Counter()\nfor entity in collection.find().limit(10000):\n    properties = entity.get(''properties'', {})\n    for prop_id in properties.keys():\n        property_counts[prop_id] += 1\n\nprint(''Top 15 properties in database:'')\nfor prop, count in property_counts.most_common(15):\n    print(f''  {prop}: {count:,} entities'')\n\n# Check new identifier properties specifically\np61_count = collection.count_documents({''properties.P61'': {''$exists'': True}})\np62_count = collection.count_documents({''properties.P62'': {''$exists'': True}})\np63_count = collection.count_documents({''properties.P63'': {''$exists'': True}})\n\nprint()\nprint(''Identifier properties:'')\nprint(f''P61 (Wikidata): {p61_count:,} entities'')\nprint(f''P62 (Geni): {p62_count:,} entities'')\nprint(f''P63 (UUID): {p63_count:,} entities'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL VERIFICATION ==='')\nprint()\n\nfor prop in [''P61'', ''P62'', ''P63'']:\n    print(f''Checking {prop} duplicates...'')\n    \n    # Count entities with this property\n    total_with_prop = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    \n    # Manual duplicate detection\n    prop_values = defaultdict(list)\n    checked = 0\n    \n    for entity in collection.find({f''properties.{prop}'': {''$exists'': True}}):\n        checked += 1\n        qid = entity[''qid'']\n        claims = entity[''properties''][prop]\n        \n        # Get unique values from claims\n        values = set()\n        for claim in claims:\n            value = claim.get(''value'', '''')\n            if value:\n                values.add(value)\n        \n        # Track which entities have each value\n        for value in values:\n            prop_values[value].append(qid)\n    \n    # Find duplicates\n    duplicates = {value: qids for value, qids in prop_values.items() if len(qids) > 1}\n    \n    print(f''  Total entities with {prop}: {total_with_prop:,}'')\n    print(f''  Unique {prop} values: {len(prop_values):,}'')\n    print(f''  {prop} values with duplicates: {len(duplicates):,}'')\n    \n    if duplicates:\n        print(f''  ERROR: Still has duplicates!'')\n    else:\n        print(f''  SUCCESS: No duplicates found!'')\n    print()\n\n# Check redirects\nredirects = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nprint(f''Redirect entities created: {redirects:,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== COMPREHENSIVE FINAL VERIFICATION ==='')\nprint()\n\n# Count redirects correctly\nredirects_found = 0\nredirect_mappings = {}\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        redirects_found += 1\n        redirect_qid = entity[''qid'']\n        target_qid = properties[''redirect''][0][''value'']\n        redirect_mappings[redirect_qid] = target_qid\n\nprint(f''Total redirect entities found: {redirects_found:,}'')\nprint(f''Redirect mappings loaded: {len(redirect_mappings):,}'')\n\n# Check for bad references\nprint()\nprint(''Verifying all references point to targets, not redirects...'')\n\nbad_references = 0\ntotal_checked = 0\n\nfor entity in collection.find():\n    total_checked += 1\n    if total_checked % 30000 == 0:\n        print(f''  Checked {total_checked:,} entities...'')\n    \n    # Skip redirect entities themselves\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    \n    # Check all property references\n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            \n            referenced_qid = None\n            if isinstance(value, str) and value.startswith(''Q''):\n                referenced_qid = value\n            elif isinstance(value, dict) and value.get(''id'', '''').startswith(''Q''):\n                referenced_qid = value[''id'']\n            \n            if referenced_qid and referenced_qid in redirect_mappings:\n                bad_references += 1\n                if bad_references <= 3:\n                    print(f''  BAD REF: {entity[\"\"qid\"\"]} prop {prop_id} points to redirect {referenced_qid} instead of target {redirect_mappings[referenced_qid]}'')\n\nprint(f''  Checked {total_checked:,} entities'')\nprint()\n\n# Final status\nprint(''=== FINAL STATUS ==='')\nprint(f''Total entities in database: {total_checked:,}'')\nprint(f''Redirect entities: {redirects_found:,}'')\nprint(f''Active entities: {total_checked - redirects_found:,}'')\nprint(f''Bad references to redirects: {bad_references:,}'')\n\nif bad_references == 0:\n    print()\n    print(''SUCCESS: Entity merger and redirect fix COMPLETELY SUCCESSFUL!'')\n    print(''   - All duplicates eliminated'')\n    print(''   - All properties merged to targets'') \n    print(''   - All references point to targets'')\n    print(''   - All redirect entities properly created'')\nelse:\n    print(f''WARNING: {bad_references:,} references still point to redirects'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== IDENTIFIER OVERLAP ANALYSIS ==='')\nprint()\n\n# Count entities with each type\ntotal_entities = collection.count_documents({})\nwikidata_only = collection.count_documents({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.P62'': {''$exists'': False}\n})\ngeni_only = collection.count_documents({\n    ''properties.P61'': {''$exists'': False},\n    ''properties.P62'': {''$exists'': True}\n})\nboth_wikidata_geni = collection.count_documents({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.P62'': {''$exists'': True}\n})\nwikidata_total = collection.count_documents({''properties.P61'': {''$exists'': True}})\ngeni_total = collection.count_documents({''properties.P62'': {''$exists'': True}})\nuuid_total = collection.count_documents({''properties.P63'': {''$exists'': True}})\nno_identifiers = collection.count_documents({\n    ''properties.P61'': {''$exists'': False},\n    ''properties.P62'': {''$exists'': False},\n    ''properties.P63'': {''$exists'': False}\n})\n\nprint(f''Total entities: {total_entities:,}'')\nprint()\nprint(''IDENTIFIER BREAKDOWN:'')\nprint(f''  Wikidata IDs only (P61): {wikidata_only:,}'')\nprint(f''  Geni IDs only (P62): {geni_only:,}'') \nprint(f''  UUID identifiers (P63): {uuid_total:,}'')\nprint(f''  BOTH Wikidata + Geni: {both_wikidata_geni:,}'')\nprint(f''  No identifiers: {no_identifiers:,}'')\nprint()\nprint(''TOTALS:'')\nprint(f''  Total Wikidata IDs: {wikidata_total:,}'')\nprint(f''  Total Geni IDs: {geni_total:,}'')\nprint(f''  Entities with BOTH: {both_wikidata_geni:,}'')\nprint()\nprint(f''Overlap percentage: {both_wikidata_geni/wikidata_total*100:.1f}% of Wikidata entities also have Geni IDs'')\n\n# Show a few examples of entities with both\nprint()\nprint(''=== SAMPLE ENTITIES WITH BOTH IDENTIFIERS ==='')\nsamples = list(collection.find({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.P62'': {''$exists'': True}\n}).limit(5))\n\nfor i, entity in enumerate(samples, 1):\n    qid = entity[''qid'']\n    label = entity.get(''labels'', {}).get(''en'', ''No label'')\n    \n    # Get identifier values\n    wikidata_id = entity[''properties''][''P61''][0].get(''value'', '''') if entity[''properties''][''P61''] else ''''\n    geni_id = entity[''properties''][''P62''][0].get(''value'', '''') if entity[''properties''][''P62''] else ''''\n    \n    print(f''{i}. {qid} (\"\"{label}\"\"):'')\n    print(f''   Wikidata: {wikidata_id}'')\n    print(f''   Geni: {geni_id}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== IDENTIFIER OVERLAP ANALYSIS ==='')\nprint()\n\n# Count all identifier properties\nwikidata_count = 0\ngeni_count = 0\nuuid_count = 0 \nboth_wd_geni = 0\ntotal_processed = 0\n\nfor entity in collection.find():\n    total_processed += 1\n    if total_processed % 20000 == 0:\n        print(f''  Analyzed {total_processed:,} entities...'')\n    \n    properties = entity.get(''properties'', {})\n    has_wikidata = ''P61'' in properties\n    has_geni = ''P62'' in properties\n    has_uuid = ''P63'' in properties\n    \n    if has_wikidata:\n        wikidata_count += 1\n    if has_geni:\n        geni_count += 1\n    if has_uuid:\n        uuid_count += 1\n    if has_wikidata and has_geni:\n        both_wd_geni += 1\n\nprint(f''  Analyzed {total_processed:,} entities total'')\nprint()\n\nprint(''IDENTIFIER COUNTS:'')\nprint(f''  Wikidata IDs (P61): {wikidata_count:,}'')\nprint(f''  Geni IDs (P62): {geni_count:,}'') \nprint(f''  UUID identifiers (P63): {uuid_count:,}'')\nprint(f''  Entities with BOTH Wikidata + Geni: {both_wd_geni:,}'')\nprint()\n\nif wikidata_count > 0:\n    overlap_pct = both_wd_geni/wikidata_count*100\n    print(f''Overlap: {overlap_pct:.1f}% of Wikidata entities also have Geni IDs'')\n    print(f''That means {both_wd_geni:,} entities could be enhanced with Wikidata data!'')\n    print()\n\n# Show sample entities with both identifiers\nprint(''=== SAMPLE ENTITIES WITH BOTH IDENTIFIERS ==='')\nsamples_found = 0\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''P61'' in properties and ''P62'' in properties:\n        samples_found += 1\n        if samples_found <= 5:\n            qid = entity[''qid'']\n            label = entity.get(''labels'', {}).get(''en'', ''No label'')\n            \n            wikidata_id = properties[''P61''][0].get(''value'', '''') if properties[''P61''] else ''''\n            geni_id = properties[''P62''][0].get(''value'', '''') if properties[''P62''] else ''''\n            \n            print(f''{samples_found}. {qid} (\"\"{label}\"\"):'')\n            print(f''   Wikidata: {wikidata_id}'')\n            print(f''   Geni: {geni_id}'')\n        else:\n            break\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== COMPREHENSIVE IDENTIFIER STATISTICS ==='')\nprint()\n\n# Complete analysis\nwikidata_only = 0\ngeni_only = 0  \nuuid_only = 0\nwikidata_geni = 0\nwikidata_uuid = 0\ngeni_uuid = 0\nall_three = 0\nno_identifiers = 0\nredirect_entities = 0\n\nwikidata_total = 0\ngeni_total = 0\nuuid_total = 0\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    \n    # Check if redirect\n    if ''redirect'' in properties:\n        redirect_entities += 1\n        continue\n    \n    has_wikidata = ''P61'' in properties\n    has_geni = ''P62'' in properties\n    has_uuid = ''P63'' in properties\n    \n    # Count totals\n    if has_wikidata:\n        wikidata_total += 1\n    if has_geni:\n        geni_total += 1\n    if has_uuid:\n        uuid_total += 1\n    \n    # Count combinations\n    if has_wikidata and has_geni and has_uuid:\n        all_three += 1\n    elif has_wikidata and has_geni:\n        wikidata_geni += 1\n    elif has_wikidata and has_uuid:\n        wikidata_uuid += 1\n    elif has_geni and has_uuid:\n        geni_uuid += 1\n    elif has_wikidata:\n        wikidata_only += 1\n    elif has_geni:\n        geni_only += 1\n    elif has_uuid:\n        uuid_only += 1\n    else:\n        no_identifiers += 1\n\nactive_entities = 145396 - redirect_entities\n\nprint(f''TOTAL DATABASE COMPOSITION:'')\nprint(f''  Total entities: 145,396'')\nprint(f''  Active entities: {active_entities:,}'')\nprint(f''  Redirect entities: {redirect_entities:,}'')\nprint()\n\nprint(''IDENTIFIER TOTALS (Active entities only):'')\nprint(f''  Wikidata IDs (P61): {wikidata_total:,}'')\nprint(f''  Geni IDs (P62): {geni_total:,}'')\nprint(f''  UUID identifiers (P63): {uuid_total:,}'')\nprint()\n\nprint(''IDENTIFIER COMBINATIONS (Active entities only):'')\nprint(f''  Wikidata only: {wikidata_only:,}'')\nprint(f''  Geni only: {geni_only:,}'')\nprint(f''  UUID only: {uuid_only:,}'')\nprint(f''  Wikidata + Geni: {wikidata_geni:,}'')\nprint(f''  Wikidata + UUID: {wikidata_uuid:,}'')\nprint(f''  Geni + UUID: {geni_uuid:,}'')\nprint(f''  All three (W+G+U): {all_three:,}'')\nprint(f''  No identifiers: {no_identifiers:,}'')\nprint()\n\nprint(''PERCENTAGES (of active entities):'')\nprint(f''  With Wikidata: {wikidata_total/active_entities*100:.1f}%'')\nprint(f''  With Geni: {geni_total/active_entities*100:.1f}%'')\nprint(f''  With UUID: {uuid_total/active_entities*100:.1f}%'')\nprint(f''  With no identifiers: {no_identifiers/active_entities*100:.1f}%'')\nprint()\n\nprint(''OVERLAP ANALYSIS:'')\ntotal_with_both_wd_geni = wikidata_geni + all_three\ntotal_with_both_wd_uuid = wikidata_uuid + all_three\ntotal_with_both_geni_uuid = geni_uuid + all_three\n\nif wikidata_total > 0:\n    print(f''  Wikidata entities that also have Geni: {total_with_both_wd_geni:,} ({total_with_both_wd_geni/wikidata_total*100:.1f}%)'')\nif geni_total > 0:\n    print(f''  Geni entities that also have Wikidata: {total_with_both_wd_geni:,} ({total_with_both_wd_geni/geni_total*100:.1f}%)'')\nif uuid_total > 0:\n    print(f''  UUID entities with other identifiers: {wikidata_uuid + geni_uuid + all_three:,} ({(wikidata_uuid + geni_uuid + all_three)/uuid_total*100:.1f}%)'')\n\nprint()\ntotal_with_any_identifier = active_entities - no_identifiers\nprint(f''COVERAGE:'')\nprint(f''  Entities with at least one identifier: {total_with_any_identifier:,} ({total_with_any_identifier/active_entities*100:.1f}%)'')\nprint(f''  Entities with no identifiers: {no_identifiers:,} ({no_identifiers/active_entities*100:.1f}%)'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DEBUGGING IDENTIFIER COUNTS ==='')\nprint()\n\n# First, let''s check what properties actually exist\nprint(''Getting all unique properties in database...'')\nall_props = set()\nsample_entities = []\n\nfor entity in collection.find().limit(1000):\n    properties = entity.get(''properties'', {})\n    all_props.update(properties.keys())\n    \n    # Collect samples of entities with identifier properties\n    if any(prop in properties for prop in [''P61'', ''P62'', ''P63'']):\n        if len(sample_entities) < 10:\n            sample_entities.append({\n                ''qid'': entity[''qid''],\n                ''is_redirect'': ''redirect'' in properties,\n                ''properties'': list(properties.keys())\n            })\n\nprint(f''Properties found in sample: {sorted(all_props)}'')\nprint()\n\nprint(''Sample entities with identifier properties:'')\nfor entity in sample_entities:\n    redirect_status = '' (REDIRECT)'' if entity[''is_redirect''] else ''''\n    print(f''  {entity[\"\"qid\"\"]}{redirect_status}: {entity[\"\"properties\"\"]}'')\n\nprint()\n\n# Direct MongoDB counts\nprint(''=== DIRECT MONGODB COUNTS ==='')\ntotal_entities = collection.count_documents({})\nredirect_entities = collection.count_documents({''properties.redirect'': {''$exists'': True}})\n\np61_total = collection.count_documents({''properties.P61'': {''$exists'': True}})\np62_total = collection.count_documents({''properties.P62'': {''$exists'': True}})\np63_total = collection.count_documents({''properties.P63'': {''$exists'': True}})\n\np61_non_redirect = collection.count_documents({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.redirect'': {''$exists'': False}\n})\np62_non_redirect = collection.count_documents({\n    ''properties.P62'': {''$exists'': True},\n    ''properties.redirect'': {''$exists'': False}\n})\np63_non_redirect = collection.count_documents({\n    ''properties.P63'': {''$exists'': True},\n    ''properties.redirect'': {''$exists'': False}\n})\n\nprint(f''Total entities: {total_entities:,}'')\nprint(f''Redirect entities: {redirect_entities:,}'')\nprint(f''Active entities: {total_entities - redirect_entities:,}'')\nprint()\nprint(''ALL ENTITIES (including redirects):'')\nprint(f''  P61 total: {p61_total:,}'')\nprint(f''  P62 total: {p62_total:,}'')\nprint(f''  P63 total: {p63_total:,}'')\nprint()\nprint(''NON-REDIRECT ENTITIES ONLY:'')\nprint(f''  P61 non-redirect: {p61_non_redirect:,}'')\nprint(f''  P62 non-redirect: {p62_non_redirect:,}'')\nprint(f''  P63 non-redirect: {p63_non_redirect:,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== INVESTIGATING QUERY ISSUE ==='')\nprint()\n\n# Check a specific entity we know has P61\nentity = collection.find_one({''qid'': ''Q16244''})\nif entity:\n    print(''Q16244 entity structure:'')\n    print(f''  QID: {entity[\"\"qid\"\"]}'')\n    print(f''  Properties: {list(entity.get(\"\"properties\"\", {}).keys())}'')\n    if ''P61'' in entity.get(''properties'', {}):\n        print(f''  P61 value: {entity[\"\"properties\"\"][\"\"P61\"\"]}'')\n    print()\n\n# Try different query approaches for P61\nprint(''Testing different query approaches for P61:'')\n\n# Approach 1: Standard exists query\ntry:\n    count1 = collection.count_documents({''properties.P61'': {''$exists'': True}})\n    print(f''  Standard $exists query: {count1:,}'')\nexcept Exception as e:\n    print(f''  Standard query error: {e}'')\n\n# Approach 2: Manual count\nmanual_count = 0\nfor entity in collection.find().limit(10000):\n    if ''P61'' in entity.get(''properties'', {}):\n        manual_count += 1\n\nprint(f''  Manual count in first 10,000: {manual_count:,}'')\n\n# Approach 3: Check if there''s an indexing issue\ntry:\n    # Find first entity with P61\n    first_p61 = collection.find_one({''qid'': ''Q16244''})\n    if first_p61 and ''P61'' in first_p61.get(''properties'', {}):\n        print(''  ✓ Q16244 definitely has P61'')\n        \n        # Try to find it with a query\n        found = collection.find_one({''qid'': ''Q16244'', ''properties.P61'': {''$exists'': True}})\n        if found:\n            print(''  ✓ Query found Q16244 with P61'')\n        else:\n            print(''  ✗ Query failed to find Q16244 with P61'')\n            \nexcept Exception as e:\n    print(f''  Query test error: {e}'')\n\n# Check redirect count issue\nprint()\nprint(''Checking redirect count:'')\nredirect_manual = 0\nfor entity in collection.find().limit(10000):\n    if ''redirect'' in entity.get(''properties'', {}):\n        redirect_manual += 1\n\nprint(f''Manual redirect count in first 10,000: {redirect_manual:,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== ACCURATE IDENTIFIER STATISTICS (MANUAL COUNT) ==='')\nprint()\n\n# Manual counting to get accurate numbers\nwikidata_count = 0\ngeni_count = 0\nuuid_count = 0\nredirect_count = 0\nboth_wd_geni = 0\ntotal_entities = 0\n\nwikidata_only = 0\ngeni_only = 0\nuuid_only = 0\nwikidata_geni = 0\nwikidata_uuid = 0\ngeni_uuid = 0\nall_three = 0\nno_identifiers = 0\n\nprint(''Manually counting all entities...'')\n\nfor entity in collection.find():\n    total_entities += 1\n    if total_entities % 20000 == 0:\n        print(f''  Processed {total_entities:,} entities...'')\n    \n    properties = entity.get(''properties'', {})\n    \n    # Check if redirect\n    is_redirect = ''redirect'' in properties\n    if is_redirect:\n        redirect_count += 1\n        continue  # Skip redirects for identifier analysis\n    \n    # Check identifiers\n    has_wikidata = ''P61'' in properties\n    has_geni = ''P62'' in properties\n    has_uuid = ''P63'' in properties\n    \n    # Count totals\n    if has_wikidata:\n        wikidata_count += 1\n    if has_geni:\n        geni_count += 1\n    if has_uuid:\n        uuid_count += 1\n    if has_wikidata and has_geni:\n        both_wd_geni += 1\n    \n    # Count combinations\n    if has_wikidata and has_geni and has_uuid:\n        all_three += 1\n    elif has_wikidata and has_geni:\n        wikidata_geni += 1\n    elif has_wikidata and has_uuid:\n        wikidata_uuid += 1\n    elif has_geni and has_uuid:\n        geni_uuid += 1\n    elif has_wikidata:\n        wikidata_only += 1\n    elif has_geni:\n        geni_only += 1\n    elif has_uuid:\n        uuid_only += 1\n    else:\n        no_identifiers += 1\n\nactive_entities = total_entities - redirect_count\n\nprint(f''  Processed {total_entities:,} entities total'')\nprint()\n\nprint(''=== CORRECTED STATISTICS ==='')\nprint()\nprint(''DATABASE COMPOSITION:'')\nprint(f''  Total entities: {total_entities:,}'')\nprint(f''  Active entities: {active_entities:,}'')\nprint(f''  Redirect entities: {redirect_count:,}'')\nprint()\n\nprint(''IDENTIFIER TOTALS (Active entities only):'')\nprint(f''  Wikidata IDs (P61): {wikidata_count:,}'')\nprint(f''  Geni IDs (P62): {geni_count:,}'')\nprint(f''  UUID identifiers (P63): {uuid_count:,}'')\nprint()\n\nprint(''IDENTIFIER COMBINATIONS (Active entities only):'')\nprint(f''  Wikidata only: {wikidata_only:,}'')\nprint(f''  Geni only: {geni_only:,}'')\nprint(f''  UUID only: {uuid_only:,}'')\nprint(f''  Wikidata + Geni: {wikidata_geni:,}'')\nprint(f''  Wikidata + UUID: {wikidata_uuid:,}'')\nprint(f''  Geni + UUID: {geni_uuid:,}'')\nprint(f''  All three (W+G+U): {all_three:,}'')\nprint(f''  No identifiers: {no_identifiers:,}'')\nprint()\n\nprint(''PERCENTAGES (of active entities):'')\nprint(f''  With Wikidata: {wikidata_count/active_entities*100:.1f}%'')\nprint(f''  With Geni: {geni_count/active_entities*100:.1f}%'')\nprint(f''  With UUID: {uuid_count/active_entities*100:.1f}%'')\nprint(f''  With no identifiers: {no_identifiers/active_entities*100:.1f}%'')\nprint()\n\nprint(''OVERLAP ANALYSIS:'')\ntotal_with_both_wd_geni = wikidata_geni + all_three\nif wikidata_count > 0:\n    print(f''  Wikidata entities that also have Geni: {total_with_both_wd_geni:,} ({total_with_both_wd_geni/wikidata_count*100:.1f}%)'')\nif geni_count > 0:\n    print(f''  Geni entities that also have Wikidata: {total_with_both_wd_geni:,} ({total_with_both_wd_geni/geni_count*100:.1f}%)'')\n\nprint()\ntotal_with_any_identifier = active_entities - no_identifiers\nprint(''COVERAGE:'')\nprint(f''  Entities with at least one identifier: {total_with_any_identifier:,} ({total_with_any_identifier/active_entities*100:.1f}%)'')\nprint(f''  Entities with no identifiers: {no_identifiers:,} ({no_identifiers/active_entities*100:.1f}%)'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== INVESTIGATING GENI ID MIGRATION ==='')\nprint()\n\n# Check if any P43 properties still exist (shouldn''t after migration)\np43_remaining = 0\nfor entity in collection.find().limit(10000):\n    if ''P43'' in entity.get(''properties'', {}):\n        p43_remaining += 1\n\nprint(f''P43 properties remaining in sample: {p43_remaining}'')\n\n# Look at some Geni ID examples\nprint()\nprint(''Sample P62 (Geni) entities:'')\ngeni_samples = []\nfor entity in collection.find():\n    if ''P62'' in entity.get(''properties'', {}):\n        geni_samples.append({\n            ''qid'': entity[''qid''],\n            ''label'': entity.get(''labels'', {}).get(''en'', ''No label''),\n            ''geni_ids'': [claim.get(''value'') for claim in entity[''properties''][''P62'']]\n        })\n        if len(geni_samples) >= 10:\n            break\n\nfor sample in geni_samples:\n    print(f''  {sample[\"\"qid\"\"]} (\"\"{sample[\"\"label\"\"]}\"\"): {sample[\"\"geni_ids\"\"]}'')\n\n# Check if this matches our original estimates\nprint()\nprint(''=== COMPARISON WITH ORIGINAL PIPELINE REPORTS ==='')\nprint(''The original merger reported processing:'')\nprint(''- Phase 1 (P63): 17,964 merges from 17,992 duplicate groups'')\nprint(''- Phase 2 (P61): 10,054 merges from 9,302 duplicate groups'') \nprint(''- Phase 3 (P62): 7,809 merges from 7,802 duplicate groups'')\nprint()\nprint(''Current active counts:'')\nprint(f''- P61: 51,635 entities'')\nprint(f''- P62: 2,641 entities'')\nprint(f''- P63: 2,698 entities'')\nprint()\nprint(''This suggests:'')\nprint(f''- P61 had ~61,689 entities before merge (51,635 + 10,054)'')\nprint(f''- P62 had ~10,450 entities before merge (2,641 + 7,809)'')\nprint(f''- P63 had ~20,662 entities before merge (2,698 + 17,964)'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/export_wikidata_no_geni.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/import_enhanced_geni_ids.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL DATABASE STATE AFTER GENI ID IMPORT ==='')\nprint()\n\n# Count total entities\ntotal_entities = collection.count_documents({})\nredirect_entities = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nactive_entities = total_entities - redirect_entities\n\nprint(f''Total entities: {total_entities:,}'')\nprint(f''Active entities: {active_entities:,}'')\nprint(f''Redirect entities: {redirect_entities:,}'')\nprint()\n\n# Count identifier properties\np61_count = 0\np62_count = 0\np63_count = 0\nboth_wikidata_geni = 0\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    \n    # Skip redirects for identifier analysis\n    if ''redirect'' in properties:\n        continue\n    \n    has_wikidata = ''P61'' in properties\n    has_geni = ''P62'' in properties\n    has_uuid = ''P63'' in properties\n    \n    if has_wikidata:\n        p61_count += 1\n    if has_geni:\n        p62_count += 1\n    if has_uuid:\n        p63_count += 1\n    if has_wikidata and has_geni:\n        both_wikidata_geni += 1\n\nprint(''IDENTIFIER STATISTICS (Active entities only):'')\nprint(f''  Wikidata IDs (P61): {p61_count:,}'')\nprint(f''  Geni IDs (P62): {p62_count:,}'')\nprint(f''  UUID identifiers (P63): {uuid_count:,}'')\nprint(f''  Entities with BOTH Wikidata + Geni: {both_wikidata_geni:,}'')\nprint()\n\nprint(''COVERAGE:'')\nif p61_count > 0:\n    overlap_pct = both_wikidata_geni/p61_count*100\n    print(f''  Wikidata entities that also have Geni: {both_wikidata_geni:,} ({overlap_pct:.1f}%)'')\n\nprint()\nprint(''COMPARISON TO BEFORE IMPORT:'')\nprint(''  Before: 51,635 Wikidata IDs, 2,641 Geni IDs'')\nprint(f''  After: {p61_count:,} Wikidata IDs, {p62_count:,} Geni IDs'')\nprint(f''  Net change: +{p62_count - 2641:,} Geni IDs'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL DATABASE STATE AFTER GENI ID IMPORT ==='')\nprint()\n\n# Count total entities\ntotal_entities = collection.count_documents({})\nredirect_entities = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nactive_entities = total_entities - redirect_entities\n\nprint(f''Total entities: {total_entities:,}'')\nprint(f''Active entities: {active_entities:,}'')\nprint(f''Redirect entities: {redirect_entities:,}'')\nprint()\n\n# Count identifier properties\np61_count = 0\np62_count = 0\np63_count = 0\nboth_wikidata_geni = 0\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    \n    # Skip redirects for identifier analysis\n    if ''redirect'' in properties:\n        continue\n    \n    has_wikidata = ''P61'' in properties\n    has_geni = ''P62'' in properties\n    has_uuid = ''P63'' in properties\n    \n    if has_wikidata:\n        p61_count += 1\n    if has_geni:\n        p62_count += 1\n    if has_uuid:\n        p63_count += 1\n    if has_wikidata and has_geni:\n        both_wikidata_geni += 1\n\nprint(''IDENTIFIER STATISTICS (Active entities only):'')\nprint(f''  Wikidata IDs (P61): {p61_count:,}'')\nprint(f''  Geni IDs (P62): {p62_count:,}'')\nprint(f''  UUID identifiers (P63): {p63_count:,}'')\nprint(f''  Entities with BOTH Wikidata + Geni: {both_wikidata_geni:,}'')\nprint()\n\nprint(''COVERAGE:'')\nif p61_count > 0:\n    overlap_pct = both_wikidata_geni/p61_count*100\n    print(f''  Wikidata entities that also have Geni: {both_wikidata_geni:,} ({overlap_pct:.1f}%)'')\n\nprint()\nprint(''COMPARISON TO BEFORE IMPORT:'')\nprint(''  Before: 51,635 Wikidata IDs, 2,641 Geni IDs'')\nprint(f''  After: {p61_count:,} Wikidata IDs, {p62_count:,} Geni IDs'')\nprint(f''  Net change: +{p62_count - 2641:,} Geni IDs'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Manual count of redirects\nredirect_count = 0\nfor entity in collection.find():\n    if ''redirect'' in entity.get(''properties'', {}):\n        redirect_count += 1\n\ntotal = collection.count_documents({})\nactive = total - redirect_count\n\nprint(''=== FINAL VERIFICATION ==='')\nprint(f''Total entities: {total:,}'')\nprint(f''Redirect entities: {redirect_count:,}'')\nprint(f''Active entities: {active:,}'')\n\n# Verify no bad references exist\nprint()\nprint(''Checking for bad references to redirects...'')\n\nredirects = {}\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        redirect_qid = entity[''qid'']\n        target_qid = properties[''redirect''][0][''value'']\n        redirects[redirect_qid] = target_qid\n\nprint(f''Loaded {len(redirects):,} redirect mappings'')\n\nbad_refs = 0\nchecked = 0\n\nfor entity in collection.find():\n    checked += 1\n    if checked % 30000 == 0:\n        print(f''  Checked {checked:,} entities...'')\n    \n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n        \n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            \n            referenced_qid = None\n            if isinstance(value, str) and value.startswith(''Q''):\n                referenced_qid = value\n            elif isinstance(value, dict) and value.get(''id'', '''').startswith(''Q''):\n                referenced_qid = value[''id'']\n            \n            if referenced_qid and referenced_qid in redirects:\n                bad_refs += 1\n\nprint(f''  Checked {checked:,} entities total'')\nprint(f''Bad references found: {bad_refs:,}'')\n\nif bad_refs == 0:\n    print()\n    print(''SUCCESS: Complete database integrity verified!'')\n    print(''- All Geni IDs successfully imported'')\n    print(''- All duplicates properly merged'') \n    print(''- All references point to targets'')\n    print(''- Database is fully consistent'')\nelse:\n    print(f''WARNING: {bad_refs:,} bad references still exist'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/resolve_redirect_chains.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/quick_redirect_analysis.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/find_missing_entities.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/import_xml_redirects.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL DATABASE STATE AFTER XML REDIRECT PROCESSING ==='')\nprint()\n\n# Manual count of redirects\nredirect_count = 0\nfor entity in collection.find():\n    if ''redirect'' in entity.get(''properties'', {}):\n        redirect_count += 1\n\ntotal = collection.count_documents({})\nactive = total - redirect_count\n\nprint(f''Total entities: {total:,}'')\nprint(f''Redirect entities: {redirect_count:,}'')\nprint(f''Active entities: {active:,}'')\n\n# Verify no bad references exist\nprint()\nprint(''Checking for bad references to redirects...'')\n\nredirects = {}\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        redirect_qid = entity[''qid'']\n        target_qid = properties[''redirect''][0][''value'']\n        redirects[redirect_qid] = target_qid\n\nprint(f''Loaded {len(redirects):,} redirect mappings'')\n\nbad_refs = 0\nchecked = 0\n\nfor entity in collection.find():\n    checked += 1\n    if checked % 30000 == 0:\n        print(f''  Checked {checked:,} entities...'')\n    \n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n        \n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            \n            referenced_qid = None\n            if isinstance(value, str) and value.startswith(''Q''):\n                referenced_qid = value\n            elif isinstance(value, dict) and value.get(''id'', '''').startswith(''Q''):\n                referenced_qid = value[''id'']\n            \n            if referenced_qid and referenced_qid in redirects:\n                bad_refs += 1\n\nprint(f''  Checked {checked:,} entities total'')\nprint(f''Bad references found: {bad_refs:,}'')\n\nif bad_refs == 0:\n    print()\n    print(''SUCCESS: Complete database integrity maintained!'')\n    print(''- All XML redirects analyzed'')\n    print(''- All redirect chains resolved'')\n    print(''- All references point to correct targets'')\n    print(''- Database is fully consistent'')\nelse:\n    print(f''INFO: {bad_refs:,} references need updating'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/remove_improper_p39.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/add_no_identifiers_p39.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/add_no_relatives_p39.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/p39_category_exporter.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/mongodb_to_wikibase_xml.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/export_geni_no_wikidata.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/import_wikidata_from_csv.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/export_wikidata_qids.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/fix_p61_format.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/mediawiki_xml_importer.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/mediawiki_xml_importer.py Immanuelle \"1996ToOmega!\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/wikibase_entity_uploader.py Immanuelle \"1996ToOmega!\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Check a sample entity''s actual structure\nsample = collection.find_one({''qid'': ''Q1''})\nif sample:\n    print(''=== SAMPLE ENTITY Q1 ==='')\n    print(''QID:'', sample[''qid''])\n    print(''Labels:'', sample.get(''labels'', {}))\n    print(''Descriptions:'', sample.get(''descriptions'', {}))\n    \n    properties = sample.get(''properties'', {})\n    print(''Properties:'', list(properties.keys()))\n    \n    # Check P61 specifically\n    if ''P61'' in properties:\n        print(''P61 structure:'', properties[''P61''][0])\n    \n    # Check another property\n    for prop in [''P55'', ''P56'', ''P20'']:\n        if prop in properties:\n            print(f''{prop} structure:'', properties[prop][0])\n            break\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport json\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Check a sample entity''s actual structure\nsample = collection.find_one({''qid'': ''Q1''})\nif sample:\n    print(''=== SAMPLE ENTITY Q1 STRUCTURE ==='')\n    print(''QID:'', sample[''qid''])\n    \n    # Check labels safely\n    labels = sample.get(''labels'', {})\n    print(''Label languages:'', list(labels.keys()))\n    if ''en'' in labels:\n        print(''English label length:'', len(labels[''en'']))\n        print(''English label type:'', type(labels[''en'']))\n    \n    # Check properties structure\n    properties = sample.get(''properties'', {})\n    print(''Properties:'', list(properties.keys())[:5])\n    \n    # Check P61 format issue\n    if ''P61'' in properties:\n        p61_claim = properties[''P61''][0]\n        print(''P61 claim keys:'', list(p61_claim.keys()))\n        print(''P61 value type:'', type(p61_claim.get(''value'')))\n        print(''P61 claim type:'', p61_claim.get(''type''))\n        \n    # Check a simpler property\n    if ''P55'' in properties:\n        p55_claim = properties[''P55''][0]\n        print(''P55 claim:'', p55_claim)\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport json\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find entity with P61\nentity_with_p61 = collection.find_one({''properties.P61'': {''$exists'': True}})\nif entity_with_p61:\n    print(''=== ENTITY WITH P61 ==='')\n    print(''QID:'', entity_with_p61[''qid''])\n    \n    p61_claims = entity_with_p61[''properties''][''P61'']\n    p61_claim = p61_claims[0]\n    \n    print(''P61 full structure:'')\n    print(json.dumps(p61_claim, indent=2, default=str))\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Check count and find sample with properties\np61_count = collection.count_documents({''properties.P61'': {''$exists'': True}})\nprint(f''Entities with P61: {p61_count}'')\n\nif p61_count > 0:\n    # Get a sample\n    sample = collection.find_one({''properties.P61'': {''$exists'': True}})\n    print(f''Sample QID: {sample[\"\"qid\"\"]}'')\n    \n    p61_claim = sample[''properties''][''P61''][0]\n    print(f''P61 type: {p61_claim.get(\"\"type\"\")}'')\n    print(f''P61 value type: {type(p61_claim.get(\"\"value\"\"))}'')\n    \n    value = p61_claim.get(''value'')\n    if isinstance(value, dict):\n        print(f''P61 value keys: {list(value.keys())}'')\n        print(f''P61 entity-type: {value.get(\"\"entity-type\"\")}'')\n        print(f''P61 id: {value.get(\"\"id\"\")}'')\n    else:\n        print(f''P61 value: {value}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== PROPERTY INVESTIGATION ==='')\n\n# Check all properties\nproperty_counts = Counter()\nfor entity in collection.find().limit(10000):\n    properties = entity.get(''properties'', {})\n    for prop_id in properties.keys():\n        property_counts[prop_id] += 1\n\nprint(''All properties found:'')\nfor prop, count in sorted(property_counts.items()):\n    print(f''  {prop}: {count:,}'')\n\nprint()\n\n# Check specific identifier properties\nfor prop in [''P44'', ''P43'', ''P60'', ''P61'', ''P62'', ''P63'']:\n    count = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    print(f''{prop}: {count:,} entities'')\n    \n    if count > 0:\n        sample = collection.find_one({f''properties.{prop}'': {''$exists'': True}})\n        sample_value = sample[''properties''][prop][0].get(''value'')\n        print(f''  Sample value: {sample_value}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DIRECT PROPERTY STRUCTURE CHECK ==='')\n\n# Find entities with P61 using the Counter approach\nfound_p61 = []\nchecked = 0\n\nfor entity in collection.find():\n    checked += 1\n    properties = entity.get(''properties'', {})\n    \n    if ''P61'' in properties:\n        found_p61.append({\n            ''qid'': entity[''qid''],\n            ''p61_claims'': properties[''P61''][:2]  # First 2 claims\n        })\n        \n        if len(found_p61) >= 5:\n            break\n    \n    if checked >= 10000:\n        break\n\nprint(f''Checked {checked:,} entities'')\nprint(f''Found {len(found_p61)} entities with P61 property'')\n\nfor item in found_p61:\n    print(f\"\"\\n{item[''qid'']}:\"\")\n    for claim in item[''p61_claims'']:\n        print(f''  Claim: {claim}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FIXING P61 PROPERTY TYPE ==='')\nprint()\n\n# Find all P61 entities\np61_entities = []\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''P61'' in properties:\n        p61_entities.append(entity)\n\nprint(f''Found {len(p61_entities):,} entities with P61 properties'')\n\n# Fix the format\nbulk_ops = []\nfixed_count = 0\n\nfor entity in p61_entities:\n    qid = entity[''qid'']\n    p61_claims = entity[''properties''][''P61'']\n    \n    # Fix each claim\n    fixed_claims = []\n    for claim in p61_claims:\n        value = claim.get(''value'', {})\n        \n        if isinstance(value, dict) and ''id'' in value:\n            # Extract the Wikidata QID string\n            wikidata_qid = value[''id'']\n            \n            # Create proper external-id format\n            fixed_claim = {\n                ''value'': wikidata_qid,\n                ''type'': ''external-id'',\n                ''claim_id'': claim.get(''claim_id'', f''{qid}_P61_{wikidata_qid}'')\n            }\n            fixed_claims.append(fixed_claim)\n    \n    if fixed_claims:\n        bulk_ops.append(\n            pymongo.UpdateOne(\n                {''qid'': qid},\n                {''$set'': {''properties.P61'': fixed_claims}}\n            )\n        )\n        fixed_count += 1\n\n# Execute fixes\nif bulk_ops:\n    collection.bulk_write(bulk_ops)\n    \nprint(f''Fixed {fixed_count:,} entities with P61 properties'')\n\n# Verify the fix\nsample = collection.find_one({''properties.P61'': {''$exists'': True}})\nif sample:\n    p61_claim = sample[''properties''][''P61''][0]\n    print(f''\\nSample fixed P61:'')\n    print(f''  Value: {p61_claim.get(\"\"value\"\")}'')\n    print(f''  Type: {p61_claim.get(\"\"type\"\")}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/fix_p61_external_id.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING P62 AND P63 FORMATS ==='')\n\n# Check P62 format\np62_sample = None\nfor entity in collection.find():\n    if ''P62'' in entity.get(''properties'', {}):\n        p62_sample = entity\n        break\n\nif p62_sample:\n    p62_claim = p62_sample[''properties''][''P62''][0]\n    print(f''P62 sample from {p62_sample[\"\"qid\"\"]}:'')\n    print(f''  Value: {p62_claim.get(\"\"value\"\")}'')\n    print(f''  Type: {p62_claim.get(\"\"type\"\")}'')\n    print(f''  Value type: {type(p62_claim.get(\"\"value\"\"))}'')\n\n# Check P63 format  \np63_sample = None\nfor entity in collection.find():\n    if ''P63'' in entity.get(''properties'', {}):\n        p63_sample = entity\n        break\n\nif p63_sample:\n    p63_claim = p63_sample[''properties''][''P63''][0]\n    print(f''P63 sample from {p63_sample[\"\"qid\"\"]}:'')\n    print(f''  Value: {p63_claim.get(\"\"value\"\")}'')\n    print(f''  Type: {p63_claim.get(\"\"type\"\")}'')\n    print(f''  Value type: {type(p63_claim.get(\"\"value\"\"))}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Check label/description format\nprint(''=== CHECKING LABEL/DESCRIPTION FORMAT ==='')\nsample = collection.find_one({''qid'': ''Q1''})\nif sample:\n    print(f''Q1 labels: {sample.get(\"\"labels\"\", {})}'')\n    print(f''Q1 descriptions: {sample.get(\"\"descriptions\"\", {})}'')\n\nprint()\nprint(''=== CHECKING ENTITY REFERENCE FORMAT ==='')\n# Check P20 (father), P42 (mother), P47 (child), P48 (spouse)\nfor prop in [''P20'', ''P42'', ''P47'', ''P48'']:\n    sample = collection.find_one({f''properties.{prop}'': {''$exists'': True}})\n    if sample:\n        claim = sample[''properties''][prop][0]\n        print(f''{prop} sample from {sample[\"\"qid\"\"]}:'')\n        print(f''  Value: {claim.get(\"\"value\"\")}'')\n        print(f''  Type: {claim.get(\"\"type\"\")}'')\n        print(f''  Value type: {type(claim.get(\"\"value\"\"))}'')\n        break\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/fix_all_wikibase_formats.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/wikibase_api_uploader.py Immanuelle \"1996ToOmega!\" test)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/fix_monolingualtext_format.py Immanuelle \"1996ToOmega!\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/analyze_monolingualtext_properties.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING SPECIFIC ENTITIES FROM XML ==='')\nprint()\n\n# Check Q16244 specifically\nentity = collection.find_one({''qid'': ''Q16244''})\nif entity:\n    properties = entity.get(''properties'', {})\n    print(''Q16244 properties:'')\n    for prop_id in [''P5'', ''P3'', ''P20'', ''P55'']:\n        if prop_id in properties:\n            claims = properties[prop_id]\n            for claim in claims[:1]:\n                value = claim.get(''value'')\n                claim_type = claim.get(''type'')\n                print(f''  {prop_id} ({claim_type}): {repr(value)[:100]}'')\n    print()\n\n# Search for P5 properties in general\nprint(''Searching for P5 properties...'')\np5_found = 0\nfor entity in collection.find({''properties.P5'': {''$exists'': True}}).limit(5):\n    p5_found += 1\n    qid = entity[''qid'']\n    p5_claims = entity[''properties''][''P5'']\n    for claim in p5_claims[:1]:\n        value = claim.get(''value'')\n        claim_type = claim.get(''type'')\n        print(f''  {qid} P5 ({claim_type}): {repr(value)[:100]}'')\n\nprint(f''Found {p5_found} entities with P5'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find an entity with P55 \nentity = collection.find_one({''properties.P55'': {''$exists'': True}})\nif entity:\n    print(''Sample P55 entity:'', entity[''qid''])\n    p55_claims = entity[''properties''][''P55'']\n    for claim in p55_claims[:3]:\n        print(''P55 claim:'')\n        print(''  Value:'', repr(claim.get(''value'')))\n        print(''  Type:'', claim.get(''type''))\n        print(''  Value type:'', type(claim.get(''value'')))\n        print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== P55 INVESTIGATION ==='')\n\n# Find entities with P55 manually\nfound_count = 0\nfor entity in collection.find().limit(1000):\n    properties = entity.get(''properties'', {})\n    if ''P55'' in properties:\n        found_count += 1\n        if found_count <= 3:\n            print(f''Entity: {entity[\"\"qid\"\"]}'')\n            p55_claims = properties[''P55'']\n            for claim in p55_claims[:2]:\n                value = claim.get(''value'')\n                claim_type = claim.get(''type'', ''unknown'')\n                print(f''  P55 value: {repr(value)}'')\n                print(f''  P55 type: {claim_type}'')\n                print(f''  Value type: {type(value).__name__}'')\n                print()\n\nprint(f''Total P55 entities found in sample: {found_count}'')\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/production_wikibase_uploader.py Immanuelle \"1996ToOmega!\" 50)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport requests\nimport json\nimport time\n\n# Test a single entity upload\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find one non-redirect entity\nentity = None\nfor ent in collection.find().limit(100):\n    if ''redirect'' not in ent.get(''properties'', {}):\n        entity = ent\n        break\n\nif entity:\n    print(f''Found test entity: {entity[\"\"qid\"\"]}'')\n    print(''Starting single entity test upload...'')\n    \n    from gedcom_tools.production_wikibase_uploader import ProductionWikibaseUploader\n    uploader = ProductionWikibaseUploader(''Immanuelle'', ''1996ToOmega!'')\n    \n    if uploader.login():\n        print(''Authentication successful'')\n        \n        # Check if entity exists\n        if not uploader.entity_exists(entity[''qid'']):\n            print(f''Entity {entity[\"\"qid\"\"]} does not exist, creating...'')\n            success = uploader.create_entity(entity)\n            print(f''Creation result: {success}'')\n        else:\n            print(f''Entity {entity[\"\"qid\"\"]} already exists'')\n    \n    uploader.mongo_client.close()\nelse:\n    print(''No non-redirect entity found'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/production_wikibase_uploader.py Immanuelle \"1996ToOmega!\" 25)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/fast_uploader.py Immanuelle \"1996ToOmega!\" 10 5)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/single_xml_exporter.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/import_genealogy_identifiers.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find an entity with multiple genealogy identifiers\nentity = collection.find_one({''properties.P1819'': {''$exists'': True}})\nif entity:\n    qid = entity[''qid'']\n    label = entity.get(''labels'', {}).get(''en'', ''No label'')\n    properties = entity.get(''properties'', {})\n    \n    print(f''Sample entity: {qid} (\"\"{label}\"\")'')\n    print()\n    \n    # Show genealogy identifiers\n    genealogy_props = [''P1819'', ''P2949'', ''P1185'', ''P4638'', ''P4159'', ''P7929'', ''P535'', ''P6821'']\n    \n    for prop in genealogy_props:\n        if prop in properties:\n            claims = properties[prop]\n            print(f''{prop}: {len(claims)} identifier(s)'')\n            for claim in claims:\n                print(f''  - {claim.get(\"\"value\"\")}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find an entity with multiple genealogy identifiers\nentity = collection.find_one({''properties.P1819'': {''$exists'': True}})\nif entity:\n    qid = entity[''qid'']\n    label = entity.get(''labels'', {}).get(''en'', ''No label'')\n    properties = entity.get(''properties'', {})\n    \n    print(f''Sample entity: {qid} (label: {label})'')\n    print()\n    \n    # Show genealogy identifiers\n    genealogy_props = [''P1819'', ''P2949'', ''P1185'', ''P4638'', ''P4159'', ''P7929'', ''P535'', ''P6821'']\n    \n    for prop in genealogy_props:\n        if prop in properties:\n            claims = properties[prop]\n            print(f''{prop}: {len(claims)} identifier(s)'')\n            for claim in claims:\n                value = claim.get(''value'', ''No value'')\n                print(f''  - {value}'')\n            print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== GENEALOGY IDENTIFIERS VERIFICATION ==='')\n\n# Count entities with each property\nprops = [''P1819'', ''P2949'', ''P1185'', ''P535'', ''P6821'']\nfor prop in props:\n    count = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    print(f''{prop}: {count} entities'')\n\n# Show sample\nentity = collection.find_one({''properties.P535'': {''$exists'': True}})\nif entity:\n    print()\n    print(f''Sample: {entity[\"\"qid\"\"]} has P535 Find a Grave ID'')\n    p535_claims = entity[''properties''][''P535'']\n    for claim in p535_claims:\n        print(f''  Find a Grave ID: {claim.get(\"\"value\"\")}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING DATABASE STATE ==='')\n\n# Check if any entities were recently modified\ntotal = collection.count_documents({})\nprint(f''Total entities: {total:,}'')\n\n# Check what properties exist\nproperty_counts = Counter()\nfor entity in collection.find().limit(1000):\n    properties = entity.get(''properties'', {})\n    for prop_id in properties.keys():\n        property_counts[prop_id] += 1\n\nprint()\nprint(''Top 15 properties in sample:'')\nfor prop, count in property_counts.most_common(15):\n    print(f''  {prop}: {count}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== GENEALOGY IDENTIFIERS FOUND ==='')\n\n# Check specific properties\ngenealogy_props = [''P2949'', ''P1819'', ''P1185'', ''P535'', ''P6821'', ''P7929'', ''P4159'']\n\nfor prop in genealogy_props:\n    count = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    if count > 0:\n        print(f''{prop}: {count:,} entities'')\n        \n        # Show sample\n        sample = collection.find_one({f''properties.{prop}'': {''$exists'': True}})\n        if sample:\n            qid = sample[''qid'']\n            label = sample.get(''labels'', {}).get(''en'', ''No label'')\n            claims = sample[''properties''][prop]\n            print(f''  Sample: {qid} (\"\"{label}\"\"): {len(claims)} claims'')\n            for claim in claims[:2]:\n                print(f''    - {claim.get(\"\"value\"\")}'')\n        print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Manual count for specific genealogy properties\ngenealogy_props = [''P2949'', ''P1819'', ''P1185'', ''P535'', ''P6821'', ''P7929'', ''P4159'', ''P4638'']\nfound_props = {}\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    for prop in genealogy_props:\n        if prop in properties:\n            if prop not in found_props:\n                found_props[prop] = []\n            found_props[prop].append(entity[''qid''])\n\nprint(''Manual count of genealogy properties:'')\nfor prop, qids in found_props.items():\n    print(f''{prop}: {len(qids)} entities'')\n    if qids:\n        print(f''  Sample QIDs: {qids[:3]}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Check a specific entity with multiple identifiers\nentity = collection.find_one({''qid'': ''Q16275''})\nif entity:\n    qid = entity[''qid'']\n    label = entity.get(''labels'', {}).get(''en'', ''No label'')\n    properties = entity.get(''properties'', {})\n    \n    print(f''=== ENTITY {qid} ==='')\n    print(f''Label: \"\"{label}\"\"'')\n    print()\n    \n    # Show all genealogy identifiers\n    genealogy_props = {\n        ''P1185'': ''Rodovid person ID'',\n        ''P1819'': ''Genealogics.org person ID'', \n        ''P2949'': ''WikiTree ID'',\n        ''P6821'': ''Geni.com profile ID'',\n        ''P535'': ''Find a Grave memorial ID'',\n        ''P7929'': ''Ancestry.com person ID'',\n        ''P4159'': ''Lemon Tree Database ID'',\n        ''P4638'': ''Malarone ID''\n    }\n    \n    print(''Genealogy identifiers:'')\n    for prop, meaning in genealogy_props.items():\n        if prop in properties:\n            claims = properties[prop]\n            print(f''  {prop} ({meaning}):'')\n            for claim in claims:\n                print(f''    - {claim.get(\"\"value\"\")}'')\n        \n    # Also show existing identifiers for comparison\n    print()\n    print(''Existing core identifiers:'')\n    for prop in [''P61'', ''P62'', ''P63'']:\n        if prop in properties:\n            claims = properties[prop]\n            prop_meaning = {''P61'': ''Wikidata QID'', ''P62'': ''Geni ID'', ''P63'': ''UUID''}[prop]\n            print(f''  {prop} ({prop_meaning}): {len(claims)} claims'')\n            for claim in claims[:2]:\n                print(f''    - {claim.get(\"\"value\"\")}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== GENEALOGY IDENTIFIERS IMPORT SUCCESS ==='')\n\n# Count total identifiers added\ngenealogy_props = [''P1185'', ''P1819'', ''P2949'', ''P6821'', ''P535'', ''P7929'', ''P4159'', ''P4638'', ''P8172'', ''P3051'']\n\ntotal_entities_with_genealogy = 0\ntotal_identifier_claims = 0\n\nfor prop in genealogy_props:\n    count = 0\n    claim_count = 0\n    for entity in collection.find({f''properties.{prop}'': {''$exists'': True}}):\n        count += 1\n        claims = entity[''properties''][prop]\n        claim_count += len(claims)\n    \n    if count > 0:\n        print(f''{prop}: {count:,} entities, {claim_count:,} total claims'')\n        total_entities_with_genealogy += count\n        total_identifier_claims += claim_count\n\nprint()\nprint(f''TOTAL: {total_identifier_claims:,} genealogy identifier claims added'')\nprint(f''These are distributed across the entities with external genealogy IDs'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find entity Q16275 and show its properties\nentity = collection.find_one({''qid'': ''Q16275''})\nif entity:\n    properties = entity.get(''properties'', {})\n    print(f''Entity Q16275 has these properties: {list(properties.keys())}'')\n    \n    if ''P1819'' in properties:\n        print(f''P1819 claims: {len(properties[\"\"P1819\"\"])}'')\n        print(f''First P1819 claim: {properties[\"\"P1819\"\"][0]}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/find_duplicate_names.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/quick_duplicate_finder.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DUPLICATE NAME ANALYSIS RESULTS ==='')\nprint()\n\n# Count entities with and without external identifiers\nexternal_props = [''P61'', ''P62'', ''P63'', ''P1185'', ''P1819'', ''P2949'', ''P4638'', ''P4159'', ''P7929'', ''P535'', ''P6821'']\n\nentities_with_ids = 0\nentities_without_ids = 0\n\nfor entity in collection.find():\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    \n    has_external = False\n    properties = entity.get(''properties'', {})\n    for prop in external_props:\n        if prop in properties:\n            has_external = True\n            break\n    \n    if has_external:\n        entities_with_ids += 1\n    else:\n        entities_without_ids += 1\n\nprint(f''Entities WITH external identifiers: {entities_with_ids:,}'')\nprint(f''Entities WITHOUT external identifiers: {entities_without_ids:,}'')\nprint()\nprint(''DUPLICATE ANALYSIS COMPLETED:'')\nprint(''- Found 7,638 potential name matches'')\nprint(''- Results saved to potential_duplicates_quick.csv'')\nprint(''- These are entities without IDs that have same names as entities with IDs'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport csv\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== ANALYZING DUPLICATE MATCHES ==='')\nprint()\n\n# Read some matches from CSV\nmatches = []\nwith open(''potential_duplicates_quick.csv'', ''r'', encoding=''utf-8'') as f:\n    reader = csv.DictReader(f)\n    for i, row in enumerate(reader):\n        if i < 5:  # First 5 matches\n            matches.append(row)\n\nprint(''Sample potential matches:'')\nfor i, match in enumerate(matches, 1):\n    no_id_qid = match[''entity_without_ids'']\n    has_id_qid = match[''entity_with_ids'']\n    name = match[''name_without_ids'']\n    \n    print(f''{i}. \"\"{name}\"\"'')\n    print(f''   Without IDs: {no_id_qid}'')\n    print(f''   With IDs: {has_id_qid}'')\n    \n    # Check what identifiers the ''with IDs'' entity has\n    entity_with_ids = collection.find_one({''qid'': has_id_qid})\n    if entity_with_ids:\n        properties = entity_with_ids.get(''properties'', {})\n        external_props = [''P61'', ''P62'', ''P63'', ''P1185'', ''P1819'', ''P2949'']\n        identifiers = []\n        for prop in external_props:\n            if prop in properties:\n                identifiers.append(prop)\n        print(f''   Has identifiers: {identifiers}'')\n    print()\n\nprint(''SUMMARY:'')\nprint(''- Found 7,638 total potential duplicate pairs'')\nprint(''- Involving 5,605 unique entities WITHOUT external identifiers'')\nprint(''- Matching against 5,460 unique entities WITH external identifiers'')\nprint(''- These are exact name matches that suggest possible duplicates'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport csv\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DUPLICATE NAME ANALYSIS COMPLETE ==='')\nprint()\n\n# Read first few matches without printing names\nwith open(''potential_duplicates_quick.csv'', ''r'', encoding=''utf-8'') as f:\n    reader = csv.DictReader(f)\n    sample_matches = []\n    for i, row in enumerate(reader):\n        if i < 3:\n            sample_matches.append(row)\n\nprint(''Sample analysis (avoiding Unicode display issues):'')\nfor i, match in enumerate(sample_matches, 1):\n    no_id_qid = match[''entity_without_ids'']\n    has_id_qid = match[''entity_with_ids'']\n    \n    print(f''Match {i}:'')\n    print(f''  Entity without external IDs: {no_id_qid}'')\n    print(f''  Entity with external IDs: {has_id_qid}'')\n    \n    # Check what external identifiers the matching entity has\n    entity_with_ids = collection.find_one({''qid'': has_id_qid})\n    if entity_with_ids:\n        properties = entity_with_ids.get(''properties'', {})\n        external_props = [''P61'', ''P62'', ''P63'', ''P1185'', ''P1819'', ''P2949'', ''P4638'', ''P7929'']\n        found_props = []\n        for prop in external_props:\n            if prop in properties:\n                found_props.append(prop)\n        print(f''  External identifiers: {found_props}'')\n    print()\n\nprint(''=== FINAL SUMMARY ==='')\nprint(''Total potential duplicate name matches found: 7,638'')\nprint(''Unique entities WITHOUT external IDs that have matches: 5,605'')\nprint(''Unique entities WITH external IDs that match: 5,460'')\nprint()\nprint(''This means:'')\nprint(''- About 10.3% of entities without external IDs have exact name matches'')\nprint(''- With entities that DO have external identifiers'')\nprint(''- These could potentially be the same people'')\nprint(''- Manual review could identify which are actual duplicates vs. different people with same names'')\n\nclient.close()\n\")",
      "Bash(git filter-branch:*)",
      "Bash(git gc:*)",
      "Bash(where java)",
      "Bash(set FILTER_BRANCH_SQUELCH_WARNING=1)",
      "Bash(git remote remove:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/create_duplicate_redirects.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== REDIRECT VERIFICATION ==='')\nprint()\n\n# Count total redirects\ntotal_redirects = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nprint(f''Total redirect entities: {total_redirects:,}'')\n\n# Count redirects created by our script (should be the new ones)\nnew_redirects = collection.count_documents({\n    ''properties.redirect'': {''$exists'': True},\n    ''labels'': {},  # These should be empty for our redirects\n    ''descriptions'': {},\n    ''aliases'': {}\n})\nprint(f''New clean redirects: {new_redirects:,}'')\n\n# Show some sample redirects\nprint()\nprint(''Sample redirects:'')\nsamples = list(collection.find({\n    ''properties.redirect'': {''$exists'': True},\n    ''labels'': {}\n}).limit(10))\n\nfor sample in samples:\n    source_qid = sample[''qid'']\n    target_qid = sample[''properties''][''redirect''][0][''value'']\n    properties_count = len([k for k in sample.get(''properties'', {}).keys() if k != ''redirect''])\n    print(f''  {source_qid} -> {target_qid} (other properties: {properties_count})'')\n\n# Verify no bad references to the new redirects exist\nprint()\nprint(''Checking for references to redirected entities...'')\n\n# Get all redirect QIDs\nredirect_qids = set()\nfor entity in collection.find({''properties.redirect'': {''$exists'': True}}, {''qid'': 1}):\n    redirect_qids.add(entity[''qid''])\n\nprint(f''Checking for bad references to {len(redirect_qids):,} redirect entities...'')\n\nbad_refs = 0\nchecked = 0\n\nfor entity in collection.find():\n    checked += 1\n    if checked % 30000 == 0:\n        print(f''  Checked {checked:,} entities...'')\n    \n    # Skip redirect entities themselves\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    \n    # Check all property references\n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            \n            referenced_qid = None\n            if isinstance(value, str) and value.startswith(''Q''):\n                referenced_qid = value\n            elif isinstance(value, dict) and value.get(''id'', '''').startswith(''Q''):\n                referenced_qid = value[''id'']\n            \n            if referenced_qid and referenced_qid in redirect_qids:\n                bad_refs += 1\n                if bad_refs <= 5:\n                    print(f''  BAD REF: {entity[\"\"qid\"\"]} prop {prop_id} -> {referenced_qid}'')\n\nprint(f''  Checked {checked:,} entities total'')\nprint(f''Bad references to redirected entities: {bad_refs:,}'')\n\nif bad_refs == 0:\n    print(''SUCCESS: No bad references found!'')\nelse:\n    print(''NOTE: Some references to redirected entities exist and may need updating'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DEBUGGING REDIRECT CREATION ==='')\nprint()\n\n# Check a specific entity that should have been redirected\ntest_qid = ''Q16251''\nentity = collection.find_one({''qid'': test_qid})\nif entity:\n    print(f''Entity {test_qid}:'')\n    print(f''  Properties: {list(entity.get(\"\"properties\"\", {}).keys())}'')\n    print(f''  Labels: {entity.get(\"\"labels\"\", {})}'')\n    print(f''  Full entity: {entity}'')\nelse:\n    print(f''Entity {test_qid} not found'')\n\n# Check redirect count with different query\nprint()\nprint(''Checking redirect counts with different queries...'')\n\n# Method 1: Direct property check\ncount1 = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nprint(f''Method 1 - Direct property check: {count1}'')\n\n# Method 2: Manual count\ncount2 = 0\nfor entity in collection.find().limit(10000):\n    if ''redirect'' in entity.get(''properties'', {}):\n        count2 += 1\nprint(f''Method 2 - Manual count (first 10k): {count2}'')\n\n# Check if the bulk operations worked\nprint()\nprint(''Looking for any entities with empty labels/descriptions...'')\nempty_count = collection.count_documents({\n    ''labels'': {},\n    ''descriptions'': {},\n    ''aliases'': {}\n})\nprint(f''Entities with empty labels/descriptions/aliases: {empty_count}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== REDIRECT VERIFICATION (MANUAL COUNT) ==='')\nprint()\n\n# Manual count of redirects\nredirect_count = 0\nnew_redirect_count = 0\nredirect_samples = []\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        redirect_count += 1\n        \n        # Check if it''s one of our new clean redirects\n        if (entity.get(''labels'', {}) == {} and \n            entity.get(''descriptions'', {}) == {} and \n            entity.get(''aliases'', {}) == {}):\n            new_redirect_count += 1\n            \n            if len(redirect_samples) < 10:\n                target_qid = properties[''redirect''][0][''value'']\n                redirect_samples.append((entity[''qid''], target_qid))\n\nprint(f''Total redirect entities: {redirect_count:,}'')\nprint(f''New clean redirects created: {new_redirect_count:,}'')\nprint()\n\nprint(''Sample new redirects:'')\nfor source, target in redirect_samples:\n    print(f''  {source} -> {target}'')\n\n# Verify the redirects match our CSV expectations\nprint()\nprint(''Verifying against CSV...'')\nimport csv\n\ncsv_redirects = set()\nwith open(''potential_duplicates_quick.csv'', ''r'', encoding=''utf-8'') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        source_qid = row[''entity_without_ids'']\n        target_qid = row[''entity_with_ids'']\n        csv_redirects.add((source_qid, target_qid))\n\nprint(f''CSV contains {len(csv_redirects)} total redirect rows'')\n\n# Remove duplicates to get unique redirects\nunique_csv_redirects = set()\nfor source, target in csv_redirects:\n    unique_csv_redirects.add(source)\n\nprint(f''CSV contains {len(unique_csv_redirects)} unique source entities'')\nprint(f''We created {new_redirect_count:,} redirects'')\n\nif new_redirect_count == len(unique_csv_redirects):\n    print(''SUCCESS: Redirect count matches CSV expectations!'')\nelse:\n    print(f''MISMATCH: Expected {len(unique_csv_redirects)}, created {new_redirect_count}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== INVESTIGATING REDIRECT COUNT MISMATCH ==='')\nprint()\n\n# Check how many redirects existed before our operation\nprint(''Checking for different types of redirects...'')\n\n# Get all redirects and analyze them\nall_redirects = []\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        source_qid = entity[''qid'']\n        target_qid = properties[''redirect''][0][''value'']\n        \n        # Check if it''s a clean redirect (created by us)\n        is_clean = (entity.get(''labels'', {}) == {} and \n                   entity.get(''descriptions'', {}) == {} and \n                   entity.get(''aliases'', {}) == {})\n        \n        # Check if it has other properties\n        other_props = [k for k in properties.keys() if k != ''redirect'']\n        \n        all_redirects.append({\n            ''source'': source_qid,\n            ''target'': target_qid,\n            ''is_clean'': is_clean,\n            ''other_props'': other_props\n        })\n\nprint(f''Total redirects found: {len(all_redirects):,}'')\n\n# Categorize redirects\nclean_redirects = [r for r in all_redirects if r[''is_clean'']]\ndirty_redirects = [r for r in all_redirects if not r[''is_clean'']]\n\nprint(f''Clean redirects (empty labels/descriptions): {len(clean_redirects):,}'')\nprint(f''Dirty redirects (have labels/descriptions): {len(dirty_redirects):,}'')\n\n# Check if the dirty redirects are from previous operations\nprint()\nprint(''Sample dirty redirects:'')\nfor i, redirect in enumerate(dirty_redirects[:5]):\n    print(f''  {redirect[\"\"source\"\"]} -> {redirect[\"\"target\"\"]} (other props: {redirect[\"\"other_props\"\"]})'')\n\n# Check what QID ranges our CSV targets\nimport csv\ncsv_sources = set()\nwith open(''potential_duplicates_quick.csv'', ''r'', encoding=''utf-8'') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        csv_sources.add(row[''entity_without_ids''])\n\nprint()\nprint(f''CSV contains {len(csv_sources)} unique source QIDs'')\n\n# Check how many of our clean redirects match the CSV\nmatching_csv = 0\nfor redirect in clean_redirects:\n    if redirect[''source''] in csv_sources:\n        matching_csv += 1\n\nprint(f''Clean redirects matching CSV: {matching_csv:,}'')\nprint(f''Clean redirects NOT in CSV: {len(clean_redirects) - matching_csv:,}'')\n\nif len(clean_redirects) - matching_csv > 0:\n    print()\n    print(''Sample clean redirects NOT from CSV:'')\n    non_csv_count = 0\n    for redirect in clean_redirects:\n        if redirect[''source''] not in csv_sources:\n            non_csv_count += 1\n            if non_csv_count <= 5:\n                print(f''  {redirect[\"\"source\"\"]} -> {redirect[\"\"target\"\"]}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING IF WE OVERWROTE EXISTING REDIRECTS ==='')\nprint()\n\n# Check if the redirect entities still point to correct targets\nimport csv\n\n# Read our expected mappings\nexpected_mappings = {}\nwith open(''potential_duplicates_quick.csv'', ''r'', encoding=''utf-8'') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        source = row[''entity_without_ids'']\n        target = row[''entity_with_ids''] \n        if source not in expected_mappings:\n            expected_mappings[source] = target\n\nprint(f''Expected {len(expected_mappings)} redirects from CSV'')\n\n# Check actual redirects for our entities\ncorrect_redirects = 0\nincorrect_redirects = 0\nmissing_redirects = 0\n\nfor source_qid, expected_target in expected_mappings.items():\n    entity = collection.find_one({''qid'': source_qid})\n    if entity and ''redirect'' in entity.get(''properties'', {}):\n        actual_target = entity[''properties''][''redirect''][0][''value'']\n        if actual_target == expected_target:\n            correct_redirects += 1\n        else:\n            incorrect_redirects += 1\n            if incorrect_redirects <= 5:\n                print(f''  INCORRECT: {source_qid} -> {actual_target}, expected {expected_target}'')\n    else:\n        missing_redirects += 1\n        if missing_redirects <= 5:\n            print(f''  MISSING: {source_qid} should redirect to {expected_target}'')\n\nprint()\nprint(f''Correct redirects: {correct_redirects:,}'')\nprint(f''Incorrect redirects: {incorrect_redirects:,}'')  \nprint(f''Missing redirects: {missing_redirects:,}'')\n\nif incorrect_redirects == 0 and missing_redirects == 0:\n    print(''SUCCESS: All expected redirects are correct!'')\nelse:\n    print(''ISSUE: Some redirects are incorrect or missing'')\n\n# The extra redirects might be from previous operations\nprint()\nprint(''The extra 35,837 redirects are likely from previous merge operations'')\nprint(''or other bulk redirect operations that cleared labels/descriptions.'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL VERIFICATION ==='')\nprint()\n\nfor prop in [''P61'', ''P62'', ''P63'']:\n    print(f''Checking {prop} duplicates...'')\n    \n    # Count entities with this property\n    total_with_prop = collection.count_documents({f''properties.{prop}'': {''$exists'': True}})\n    \n    # Manual duplicate detection\n    prop_values = defaultdict(list)\n    checked = 0\n    \n    for entity in collection.find({f''properties.{prop}'': {''$exists'': True}}):\n        checked += 1\n        qid = entity[''qid'']\n        claims = entity[''properties''][prop]\n        \n        # Get unique values from claims\n        values = set()\n        for claim in claims:\n            value = claim.get(''value'', '''')\n            if value:\n                values.add(value)\n        \n        # Track which entities have each value\n        for value in values:\n            prop_values[value].append(qid)\n    \n    # Find duplicates\n    duplicates = {value: qids for value, qids in prop_values.items() if len(qids) > 1}\n    \n    print(f''  Total entities with {prop}: {total_with_prop:,}'')\n    print(f''  Unique {prop} values: {len(prop_values):,}'')\n    print(f''  {prop} values with duplicates: {len(duplicates):,}'')\n    \n    if duplicates:\n        print(f''  ERROR: Still has duplicates!'')\n    else:\n        print(f''  SUCCESS: No duplicates found!'')\n    print()\n\n# Check redirects\nredirects = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nprint(f''Redirect entities created: {redirects:,}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import defaultdict\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== COMPREHENSIVE FINAL VERIFICATION ==='')\nprint()\n\n# Count redirects correctly\nredirects_found = 0\nredirect_mappings = {}\n\nfor entity in collection.find():\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        redirects_found += 1\n        redirect_qid = entity[''qid'']\n        target_qid = properties[''redirect''][0][''value'']\n        redirect_mappings[redirect_qid] = target_qid\n\nprint(f''Total redirect entities found: {redirects_found:,}'')\nprint(f''Redirect mappings loaded: {len(redirect_mappings):,}'')\n\n# Check for bad references\nprint()\nprint(''Verifying all references point to targets, not redirects...'')\n\nbad_references = 0\ntotal_checked = 0\n\nfor entity in collection.find():\n    total_checked += 1\n    if total_checked % 30000 == 0:\n        print(f''  Checked {total_checked:,} entities...'')\n    \n    # Skip redirect entities themselves\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    \n    # Check all property references\n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            \n            referenced_qid = None\n            if isinstance(value, str) and value.startswith(''Q''):\n                referenced_qid = value\n            elif isinstance(value, dict) and value.get(''id'', '''').startswith(''Q''):\n                referenced_qid = value[''id'']\n            \n            if referenced_qid and referenced_qid in redirect_mappings:\n                bad_references += 1\n                if bad_references <= 3:\n                    print(f''  BAD REF: {entity[\"\"qid\"\"]} prop {prop_id} points to redirect {referenced_qid} instead of target {redirect_mappings[referenced_qid]}'')\n\nprint(f''  Checked {total_checked:,} entities'')\nprint()\n\n# Final status\nprint(''=== FINAL STATUS ==='')\nprint(f''Total entities in database: {total_checked:,}'')\nprint(f''Redirect entities: {redirects_found:,}'')\nprint(f''Active entities: {total_checked - redirects_found:,}'')\nprint(f''Bad references to redirects: {bad_references:,}'')\n\nif bad_references == 0:\n    print()\n    print(''SUCCESS: Entity merger and redirect fix COMPLETELY SUCCESSFUL!'')\n    print(''   - All duplicates eliminated'')\n    print(''   - All properties merged to targets'') \n    print(''   - All references point to targets'')\n    print(''   - All redirect entities properly created'')\nelse:\n    print(f''WARNING: {bad_references:,} references still point to redirects'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== ANALYZING DUPLICATE PROPERTIES ==='')\nprint()\n\n# Sample entities to check for duplicates\nduplicate_stats = {}\ntotal_claims = 0\nduplicate_claims = 0\nentities_with_duplicates = 0\nsample_duplicates = []\n\nchecked_entities = 0\nfor entity in collection.find().limit(10000):  # Sample first 10k entities\n    checked_entities += 1\n    if checked_entities % 2000 == 0:\n        print(f''  Analyzed {checked_entities:,} entities...'')\n    \n    # Skip redirect entities\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    \n    qid = entity[''qid'']\n    properties = entity.get(''properties'', {})\n    entity_has_duplicates = False\n    \n    for prop_id, claims in properties.items():\n        if prop_id == ''redirect'':\n            continue\n            \n        total_claims += len(claims)\n        \n        # Check for duplicates within this property\n        seen_values = set()\n        unique_claims = []\n        duplicates_found = 0\n        \n        for claim in claims:\n            # Create a key based on the claim value and type\n            value = claim.get(''value'')\n            claim_type = claim.get(''type'', '''')\n            \n            # Handle different value types\n            if isinstance(value, dict):\n                if ''id'' in value:\n                    key = (prop_id, value[''id''], claim_type)\n                elif ''text'' in value:\n                    key = (prop_id, value[''text''], value.get(''language'', ''''), claim_type)\n                else:\n                    key = (prop_id, str(value), claim_type)\n            else:\n                key = (prop_id, str(value), claim_type)\n            \n            if key in seen_values:\n                duplicates_found += 1\n                duplicate_claims += 1\n                entity_has_duplicates = True\n            else:\n                seen_values.add(key)\n                unique_claims.append(claim)\n        \n        if duplicates_found > 0:\n            if prop_id not in duplicate_stats:\n                duplicate_stats[prop_id] = 0\n            duplicate_stats[prop_id] += duplicates_found\n            \n            # Collect samples\n            if len(sample_duplicates) < 10:\n                sample_duplicates.append({\n                    ''qid'': qid,\n                    ''property'': prop_id,\n                    ''total_claims'': len(claims),\n                    ''unique_claims'': len(unique_claims),\n                    ''duplicates'': duplicates_found\n                })\n    \n    if entity_has_duplicates:\n        entities_with_duplicates += 1\n\nprint(f''  Analyzed {checked_entities:,} entities total'')\nprint()\n\nprint(''=== DUPLICATE ANALYSIS RESULTS ==='')\nprint(f''Total claims analyzed: {total_claims:,}'')\nprint(f''Duplicate claims found: {duplicate_claims:,}'')\nprint(f''Entities with duplicates: {entities_with_duplicates:,}'')\nprint(f''Duplicate percentage: {duplicate_claims/total_claims*100:.2f}%'')\nprint()\n\nprint(''Properties with most duplicates:'')\nfor prop, count in sorted(duplicate_stats.items(), key=lambda x: x[1], reverse=True)[:10]:\n    print(f''  {prop}: {count:,} duplicate claims'')\n\nprint()\nprint(''Sample entities with duplicates:'')\nfor sample in sample_duplicates:\n    print(f''  {sample[\"\"qid\"\"]} {sample[\"\"property\"\"]}: {sample[\"\"total_claims\"\"]} -> {sample[\"\"unique_claims\"\"]} claims ({sample[\"\"duplicates\"\"]} duplicates)'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/remove_duplicate_properties.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINAL DATABASE STATE AFTER DEDUPLICATION ==='')\nprint()\n\n# Count total entities and claims\ntotal_entities = collection.count_documents({})\nredirect_entities = 0\nactive_entities = 0\ntotal_claims = 0\n\nfor entity in collection.find():\n    if ''redirect'' in entity.get(''properties'', {}):\n        redirect_entities += 1\n    else:\n        active_entities += 1\n        properties = entity.get(''properties'', {})\n        for prop_id, claims in properties.items():\n            if prop_id != ''redirect'':\n                total_claims += len(claims)\n\nprint(f''Total entities: {total_entities:,}'')\nprint(f''Active entities: {active_entities:,}'')\nprint(f''Redirect entities: {redirect_entities:,}'')\nprint(f''Total property claims: {total_claims:,}'')\nprint()\n\n# Check for any remaining duplicates in a larger sample\nprint(''Final verification of duplicate removal...'')\nsample_size = 5000\nchecked = 0\nduplicates_found = 0\n\nfor entity in collection.find().limit(sample_size):\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n        \n    checked += 1\n    properties = entity.get(''properties'', {})\n    \n    for prop_id, claims in properties.items():\n        if prop_id == ''redirect'':\n            continue\n            \n        # Check for duplicates\n        seen_keys = set()\n        for claim in claims:\n            value = claim.get(''value'')\n            claim_type = claim.get(''type'', '''')\n            \n            if isinstance(value, dict):\n                if ''id'' in value:\n                    key = (value[''id''], claim_type)\n                elif ''text'' in value:\n                    key = (value[''text''], value.get(''language'', ''''), claim_type)\n                else:\n                    key = (str(value), claim_type)\n            else:\n                key = (str(value), claim_type)\n            \n            if key in seen_keys:\n                duplicates_found += 1\n                print(f''  Duplicate found: {entity[\"\"qid\"\"]} {prop_id} -> {value}'')\n                break\n            seen_keys.add(key)\n\nprint(f''Checked {checked:,} active entities'')\nprint(f''Duplicates found: {duplicates_found}'')\n\nif duplicates_found == 0:\n    print(''SUCCESS: No duplicates found in verification sample!'')\nelse:\n    print(f''WARNING: {duplicates_found} duplicates still exist'')\n\nprint()\nprint(''=== SPACE SAVINGS SUMMARY ==='')\nprint(''Before: 681,266 total property claims'')\nprint(''After: 578,091 total property claims'') \nprint(''Removed: 103,175 duplicate claims (15.14% reduction)'')\nprint(''Entities cleaned: 38,872 entities had duplicates removed'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Find entity Q81918\nentity = collection.find_one({''qid'': ''Q81918''})\n\nif entity:\n    print(f''Entity: {entity[\"\"qid\"\"]}'')\n    \n    # Get labels\n    labels = entity.get(''labels'', {})\n    if labels:\n        print(''Labels:'')\n        for lang, label in labels.items():\n            print(f''  {lang}: {label}'')\n    else:\n        print(''Labels: (none)'')\n    \n    # Get descriptions  \n    descriptions = entity.get(''descriptions'', {})\n    if descriptions:\n        print(''Descriptions:'')\n        for lang, desc in descriptions.items():\n            print(f''  {lang}: {desc}'')\n    else:\n        print(''Descriptions: (none)'')\n        \n    # Check if it''s a redirect\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        target = properties[''redirect''][0][''value'']\n        print(f''REDIRECT: This entity redirects to {target}'')\n    else:\n        print(''Type: Active entity'')\n        \nelse:\n    print(''Entity Q81918 not found in database'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\n# Check Q16251 - should be a redirect\nentity = collection.find_one({''qid'': ''Q16251''})\nif entity:\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        target = properties[''redirect''][0][''value'']\n        print(f''Q16251 is a REDIRECT to {target}'')\n    else:\n        print(''Q16251 is NOT a redirect'')\n        print(f''Properties: {list(properties.keys())}'')\nelse:\n    print(''Q16251 not found'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/regenerate_analysis_csvs.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport csv\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== VERIFYING CSVs EXCLUDE REDIRECTS ==='')\nprint()\n\n# Check a few entities from the problematic CSV\ntest_qids = [''Q16242'', ''Q16243'', ''Q16249'', ''Q16250'', ''Q16252'']\n\nredirect_found = False\nfor qid in test_qids:\n    entity = collection.find_one({''qid'': qid})\n    if entity:\n        properties = entity.get(''properties'', {})\n        if ''redirect'' in properties:\n            target = properties[''redirect''][0][''value'']\n            print(f''ERROR: {qid} is a redirect to {target}'')\n            redirect_found = True\n        else:\n            print(f''✓ {qid} is active (not a redirect)'')\n    else:\n        print(f''✗ {qid} not found'')\n\nprint()\nif not redirect_found:\n    print(''SUCCESS: All tested entities are active (no redirects found)'')\nelse:\n    print(''ISSUE: Some entities in CSV are still redirects'')\n\n# Check statistics\nprint()\nprint(''CSV Statistics:'')\ncsv_files = [\n    ''all_wikidata_qids.csv'',\n    ''geni_ids_no_wikidata.csv'', \n    ''geni_ids_with_wikidata.csv'',\n    ''wikidata_genealogy_data.csv'',\n    ''has_identifiers_and_relatives.csv'',\n    ''no_identifiers_only.csv'',\n    ''no_relatives_only.csv'',\n    ''both_no_identifiers_and_no_relatives.csv''\n]\n\nfor filename in csv_files:\n    try:\n        with open(f''analysis/{filename}'', ''r'', encoding=''utf-8'') as f:\n            reader = csv.reader(f)\n            rows = list(reader)\n            # Skip comment and header rows\n            data_rows = [row for row in rows if not row[0].startswith(''#'') and row[0] != ''qid'']\n            print(f''  {filename}: {len(data_rows):,} entities'')\n    except FileNotFoundError:\n        print(f''  {filename}: File not found'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport csv\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== VERIFYING CSVs EXCLUDE REDIRECTS ==='')\nprint()\n\n# Check a few entities from the problematic CSV\ntest_qids = [''Q16242'', ''Q16243'', ''Q16249'', ''Q16250'', ''Q16252'']\n\nredirect_found = False\nfor qid in test_qids:\n    entity = collection.find_one({''qid'': qid})\n    if entity:\n        properties = entity.get(''properties'', {})\n        if ''redirect'' in properties:\n            target = properties[''redirect''][0][''value'']\n            print(f''ERROR: {qid} is a redirect to {target}'')\n            redirect_found = True\n        else:\n            print(f''OK: {qid} is active (not a redirect)'')\n    else:\n        print(f''NOT FOUND: {qid}'')\n\nprint()\nif not redirect_found:\n    print(''SUCCESS: All tested entities are active (no redirects found)'')\nelse:\n    print(''ISSUE: Some entities in CSV are still redirects'')\n\n# Check statistics\nprint()\nprint(''CSV Statistics:'')\ncsv_files = [\n    ''all_wikidata_qids.csv'',\n    ''geni_ids_no_wikidata.csv'', \n    ''geni_ids_with_wikidata.csv'',\n    ''wikidata_genealogy_data.csv'',\n    ''has_identifiers_and_relatives.csv'',\n    ''no_identifiers_only.csv'',\n    ''no_relatives_only.csv'',\n    ''both_no_identifiers_and_no_relatives.csv''\n]\n\nfor filename in csv_files:\n    try:\n        with open(f''analysis/{filename}'', ''r'', encoding=''utf-8'') as f:\n            reader = csv.reader(f)\n            rows = list(reader)\n            # Skip comment and header rows\n            data_rows = [row for row in rows if not row[0].startswith(''#'') and row[0] != ''qid'']\n            print(f''  {filename}: {len(data_rows):,} entities'')\n    except FileNotFoundError:\n        print(f''  {filename}: File not found'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DEBUGGING CATEGORIZATION LOGIC ==='')\nprint()\n\n# Sample some entities to check categorization\nsample_count = 0\ncategories_found = {\n    ''has_identifiers'': 0,\n    ''has_relatives'': 0,\n    ''has_both'': 0,\n    ''has_neither'': 0,\n    ''has_ids_no_relatives'': 0,\n    ''has_relatives_no_ids'': 0\n}\n\nfor entity in collection.find().limit(10000):\n    # Skip redirect entities\n    properties = entity.get(''properties'', {})\n    if ''redirect'' in properties:\n        continue\n        \n    sample_count += 1\n    qid = entity[''qid'']\n    \n    # Check for external identifiers\n    wikidata_ids = ''P61'' in properties\n    geni_ids = ''P62'' in properties  \n    uuid_ids = ''P63'' in properties\n    genealogy_props = [''P1185'', ''P1819'', ''P2949'', ''P4638'', ''P4159'', ''P7929'', ''P535'', ''P6821'']\n    genealogy_ids = any(prop in properties for prop in genealogy_props)\n    \n    has_any_identifier = wikidata_ids or geni_ids or uuid_ids or genealogy_ids\n    \n    # Check for family relationships\n    fathers = ''P20'' in properties\n    mothers = ''P42'' in properties\n    children = ''P47'' in properties\n    spouses = ''P48'' in properties\n    \n    has_any_relative = fathers or mothers or children or spouses\n    \n    # Count categories\n    if has_any_identifier:\n        categories_found[''has_identifiers''] += 1\n    if has_any_relative:\n        categories_found[''has_relatives''] += 1\n    if has_any_identifier and has_any_relative:\n        categories_found[''has_both''] += 1\n    if not has_any_identifier and not has_any_relative:\n        categories_found[''has_neither''] += 1\n    if has_any_identifier and not has_any_relative:\n        categories_found[''has_ids_no_relatives''] += 1\n    if not has_any_identifier and has_any_relative:\n        categories_found[''has_relatives_no_ids''] += 1\n    \n    # Show first few examples of each category\n    if sample_count <= 20:\n        id_list = []\n        if wikidata_ids: id_list.append(''Wikidata'')\n        if geni_ids: id_list.append(''Geni'')\n        if uuid_ids: id_list.append(''UUID'')\n        if genealogy_ids: id_list.append(''Genealogy'')\n        \n        rel_list = []\n        if fathers: rel_list.append(''Father'')\n        if mothers: rel_list.append(''Mother'')\n        if children: rel_list.append(''Children'')\n        if spouses: rel_list.append(''Spouses'')\n        \n        print(f''{qid}: IDs={id_list} Relatives={rel_list}'')\n\nprint()\nprint(f''Sample of {sample_count:,} active entities:'')\nprint(f''  Has identifiers: {categories_found[\"\"has_identifiers\"\"]:,}'')\nprint(f''  Has relatives: {categories_found[\"\"has_relatives\"\"]:,}'')\nprint(f''  Has both: {categories_found[\"\"has_both\"\"]:,}'')\nprint(f''  Has neither: {categories_found[\"\"has_neither\"\"]:,}'')\nprint(f''  Has IDs but no relatives: {categories_found[\"\"has_ids_no_relatives\"\"]:,}'')\nprint(f''  Has relatives but no IDs: {categories_found[\"\"has_relatives_no_ids\"\"]:,}'')\n\n# Check the math\ntotal_check = (categories_found[''has_both''] + \n               categories_found[''has_neither''] + \n               categories_found[''has_ids_no_relatives''] + \n               categories_found[''has_relatives_no_ids''])\nprint(f''  Total check: {total_check:,} (should equal {sample_count:,})'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== INVESTIGATING FAMILY RELATIONSHIP PROPERTIES ==='')\nprint()\n\n# Find entities that should have family relationships\nrelationship_props = [''P20'', ''P42'', ''P47'', ''P48'']\nprop_names = {''P20'': ''father'', ''P42'': ''mother'', ''P47'': ''child'', ''P48'': ''spouse''}\n\nfor prop in relationship_props:\n    count = 0\n    for entity in collection.find().limit(10000):\n        if ''redirect'' in entity.get(''properties'', {}):\n            continue\n        if prop in entity.get(''properties'', {}):\n            count += 1\n            if count <= 3:  # Show first 3 examples\n                qid = entity[''qid'']\n                claims = entity[''properties''][prop]\n                print(f''{qid} has {prop} ({prop_names[prop]}): {len(claims)} claims'')\n                for claim in claims[:2]:\n                    value = claim.get(''value'')\n                    claim_type = claim.get(''type'')\n                    print(f''  Value: {value} (type: {claim_type})'')\n    \n    print(f''Found {count} entities with {prop} ({prop_names[prop]}) in sample'')\n    print()\n\n# Let''s also check the overall database counts\nprint(''=== FULL DATABASE PROPERTY COUNTS ==='')\nfor prop in relationship_props:\n    # Manual count since MongoDB queries seem inconsistent\n    count = 0\n    for entity in collection.find():\n        if ''redirect'' in entity.get(''properties'', {}):\n            continue\n        if prop in entity.get(''properties'', {}):\n            count += 1\n    print(f''{prop} ({prop_names[prop]}): {count:,} entities'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== FINDING ACTUAL RELATIONSHIP PROPERTIES ==='')\nprint()\n\n# Count all properties to see what exists\nproperty_counts = Counter()\nchecked = 0\n\nfor entity in collection.find():\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    checked += 1\n    if checked >= 10000:  # Sample first 10k\n        break\n        \n    properties = entity.get(''properties'', {})\n    for prop_id in properties.keys():\n        property_counts[prop_id] += 1\n\nprint(f''Property counts in sample of {checked:,} active entities:'')\nprint()\n\n# Look for relationship-like properties\nrelationship_candidates = []\nfor prop, count in property_counts.most_common(30):\n    print(f''{prop}: {count:,}'')\n    # Look for property IDs that might be relationships\n    if prop.startswith(''P'') and count > 100:  # Common properties\n        relationship_candidates.append(prop)\n\nprint()\nprint(''=== CHECKING SPECIFIC PROPERTIES FOR RELATIONSHIPS ==='')\n\n# Check some promising properties for relationship content\ntest_props = [''P4'', ''P5'', ''P15'', ''P45'', ''P46'']  # Common properties that might be relationships\n\nfor prop in test_props:\n    if prop in property_counts:\n        print(f''\\nChecking {prop} (found in {property_counts[prop]} entities):'')\n        sample_entity = None\n        for entity in collection.find():\n            if ''redirect'' in entity.get(''properties'', {}):\n                continue\n            if prop in entity.get(''properties'', {}):\n                sample_entity = entity\n                break\n        \n        if sample_entity:\n            qid = sample_entity[''qid'']\n            claims = sample_entity[''properties''][prop]\n            print(f''  Sample from {qid}: {len(claims)} claims'')\n            for claim in claims[:2]:\n                value = claim.get(''value'')\n                claim_type = claim.get(''type'')\n                print(f''    Value: {value} (type: {claim_type})'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== INVESTIGATING PROPERTY MEANINGS ==='')\nprint()\n\n# Let''s look at entities that should have family relationships\n# Check entities with genealogy identifiers - they should have family data\n\ngenealogy_entity = None\nfor entity in collection.find():\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    properties = entity.get(''properties'', {})\n    \n    # Find entity with Geni ID (should have family relationships)\n    if ''P62'' in properties:\n        genealogy_entity = entity\n        break\n\nif genealogy_entity:\n    qid = genealogy_entity[''qid'']\n    label = genealogy_entity.get(''labels'', {}).get(''en'', ''No label'')\n    print(f''Genealogy entity example: {qid} (\"\"{label}\"\")'')\n    print()\n    \n    properties = genealogy_entity.get(''properties'', {})\n    print(''All properties on this entity:'')\n    for prop_id, claims in properties.items():\n        print(f''  {prop_id}: {len(claims)} claims'')\n        # Show sample values for each property\n        for claim in claims[:1]:  # Just first claim\n            value = claim.get(''value'')\n            claim_type = claim.get(''type'')\n            if isinstance(value, str) and len(value) > 100:\n                value = value[:50] + ''...''\n            print(f''    Sample: {value} (type: {claim_type})'')\n\nprint()\nprint(''=== CHECKING ENTITY-ID PROPERTIES FOR RELATIONSHIPS ==='')\n\n# Look for properties that reference other Q entities (likely relationships)\nentity_ref_props = []\nfor entity in collection.find().limit(1000):\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    properties = entity.get(''properties'', {})\n    \n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            # Check if value references another entity\n            if isinstance(value, str) and value.startswith(''Q'') and value[1:].isdigit():\n                if prop_id not in entity_ref_props:\n                    entity_ref_props.append(prop_id)\n                    print(f''{prop_id}: references entity {value}'')\n                break\n        if len(entity_ref_props) >= 10:  # Limit output\n            break\n    if len(entity_ref_props) >= 10:\n        break\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== COMPREHENSIVE PROPERTY ANALYSIS ==='')\nprint()\n\n# Get all unique properties in the database\nall_properties = set()\nproperty_counts = Counter()\nsample_values = {}\n\nchecked = 0\nfor entity in collection.find():\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    checked += 1\n    if checked > 20000:  # Larger sample\n        break\n        \n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        all_properties.add(prop_id)\n        property_counts[prop_id] += 1\n        \n        # Collect sample values to understand what each property is\n        if prop_id not in sample_values and claims:\n            claim = claims[0]\n            value = claim.get(''value'')\n            claim_type = claim.get(''type'')\n            \n            # Simplify value for display\n            if isinstance(value, dict):\n                if ''id'' in value:\n                    sample_values[prop_id] = f''Entity reference: {value[\"\"id\"\"]}''\n                elif ''text'' in value:\n                    sample_values[prop_id] = f''Text: {value[\"\"text\"\"][:30]}...''\n                elif ''time'' in value:\n                    sample_values[prop_id] = f''Date: {value[\"\"time\"\"][:10]}''\n                else:\n                    sample_values[prop_id] = f''Dict: {str(value)[:50]}...''\n            else:\n                sample_values[prop_id] = f''{claim_type}: {str(value)[:50]}...''\n\nprint(f''Found {len(all_properties)} unique properties in {checked:,} entities:'')\nprint()\n\n# Sort by frequency and show sample values\nfor prop in sorted(property_counts.keys(), key=lambda x: property_counts[x], reverse=True):\n    count = property_counts[prop]\n    sample = sample_values.get(prop, ''No sample'')\n    print(f''{prop}: {count:,} entities - {sample}'')\n\nprint()\nprint(''=== CONCLUSION ==='')\nprint(''This database appears to contain:'')\nprint(''- Individual characteristics (names, dates, identifiers)'')\nprint(''- NO family relationship properties'')\nprint(''- Therefore, ALL entities will be categorized as \"\"no relatives\"\"'')\nprint()\nprint(''The categories should be:'')\nprint(''- Entities WITH identifiers (but no relatives): ~57K'')\nprint(''- Entities WITHOUT identifiers (and no relatives): ~47K'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport csv\n\n# Check the math\nprint(''=== VERIFICATION OF CORRECTED ANALYSIS ==='')\nprint()\n\ncategories = {\n    ''all_wikidata_qids'': 51644,\n    ''geni_ids_no_wikidata'': 1474, \n    ''geni_ids_with_wikidata'': 5568,\n    ''no_relatives_only'': 55291,  # Entities with identifiers but no relatives\n    ''both_no_identifiers_and_no_relatives'': 48664  # Entities with neither\n}\n\nprint(''Active entities (excluding redirects): 103,955'')\nprint()\nprint(''Categories:'')\nfor category, count in categories.items():\n    print(f''  {category}: {count:,}'')\n\nprint()\nprint(''Math check:'')\nentities_with_identifiers = categories[''no_relatives_only'']\nentities_without_identifiers = categories[''both_no_identifiers_and_no_relatives'']\ntotal_check = entities_with_identifiers + entities_without_identifiers\n\nprint(f''  Entities WITH identifiers (no relatives): {entities_with_identifiers:,}'')\nprint(f''  Entities WITHOUT identifiers (no relatives): {entities_without_identifiers:,}'')\nprint(f''  Total: {total_check:,}'')\nprint(f''  Expected: 103,955'')\nprint(f''  Match: {total_check == 103955}'')\n\nprint()\nprint(''Why the other categories are empty:'')\nprint(''  has_identifiers_and_relatives: 0 (no family data exists)'')\nprint(''  no_identifiers_only: 0 (no family data exists)'')\nprint()\nprint(''This is CORRECT because this database contains:'')\nprint(''- Individual characteristics only (names, dates, external IDs)'')\nprint(''- NO family relationship properties'')\nprint(''- Therefore ALL entities have \"\"no relatives\"\"'')\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== URGENT: CHECKING FOR MISSING FAMILY RELATIONSHIPS ==='')\nprint()\n\n# Let''s check all possible property IDs that might be family relationships\nall_properties = set()\nfor entity in collection.find().limit(5000):\n    if ''redirect'' not in entity.get(''properties'', {}):\n        properties = entity.get(''properties'', {})\n        all_properties.update(properties.keys())\n\nprint(f''All properties found: {sorted(all_properties)}'')\nprint()\n\n# Check for any properties that might reference other entities (relationships)\nentity_reference_props = []\nfor entity in collection.find().limit(1000):\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n    properties = entity.get(''properties'', {})\n    \n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            # Check if this references another Q entity\n            if isinstance(value, str) and value.startswith(''Q'') and len(value) > 1:\n                try:\n                    int(value[1:])  # Check if rest is numeric\n                    if prop_id not in entity_reference_props:\n                        entity_reference_props.append(prop_id)\n                        print(f''Property {prop_id} references entity: {value}'')\n                        break\n                except ValueError:\n                    pass\n        if len(entity_reference_props) >= 10:\n            break\n\nprint()\nprint(f''Properties that reference other entities: {entity_reference_props}'')\n\n# Let''s specifically check what happened during our operations\nprint()\nprint(''=== CHECKING RECENT OPERATION IMPACTS ==='')\n\n# Check if the duplicate removal operation might have affected relationships\nprint(''Looking for any signs of family relationship properties...'')\n\n# Check if P20, P42, P47, P48 existed before and were removed\nrelationship_props = [''P20'', ''P42'', ''P47'', ''P48'']  # father, mother, child, spouse\nfor prop in relationship_props:\n    count = 0\n    for entity in collection.find().limit(1000):\n        if prop in entity.get(''properties'', {}):\n            count += 1\n    print(f''{prop}: {count} entities found'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== MANUAL SEARCH FOR FAMILY RELATIONSHIPS ==='')\nprint()\n\n# Manual count - check every entity\nrelationship_props = [''P20'', ''P42'', ''P47'', ''P48'']  # father, mother, child, spouse\nprop_counts = {prop: 0 for prop in relationship_props}\nprop_examples = {prop: [] for prop in relationship_props}\n\nchecked = 0\nfor entity in collection.find():\n    checked += 1\n    if checked % 20000 == 0:\n        print(f''  Checked {checked:,} entities...'')\n    \n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n        \n    properties = entity.get(''properties'', {})\n    \n    for prop in relationship_props:\n        if prop in properties:\n            prop_counts[prop] += 1\n            if len(prop_examples[prop]) < 3:\n                prop_examples[prop].append({\n                    ''qid'': entity[''qid''],\n                    ''claims'': properties[prop][:1]  # First claim only\n                })\n\nprint(f''  Checked {checked:,} entities total'')\nprint()\n\nprint(''=== FAMILY RELATIONSHIP SEARCH RESULTS ==='')\nfor prop in relationship_props:\n    count = prop_counts[prop]\n    examples = prop_examples[prop]\n    prop_names = {''P20'': ''father'', ''P42'': ''mother'', ''P47'': ''child'', ''P48'': ''spouse''}\n    \n    print(f''{prop} ({prop_names[prop]}): {count:,} entities'')\n    if examples:\n        for example in examples:\n            qid = example[''qid'']\n            claims = example[''claims'']\n            for claim in claims:\n                value = claim.get(''value'')\n                print(f''  Example: {qid} -> {value}'')\n\n# Also check for any properties that might be relationships with different IDs\nprint()\nprint(''=== CHECKING ALL PROPERTIES FOR ENTITY REFERENCES ==='')\nentity_ref_counts = {}\n\nfor entity in collection.find().limit(10000):  # Sample 10k entities\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n        \n    properties = entity.get(''properties'', {})\n    for prop_id, claims in properties.items():\n        for claim in claims:\n            value = claim.get(''value'')\n            # Check if this looks like an entity reference\n            if isinstance(value, str) and value.startswith(''Q'') and len(value) > 1:\n                try:\n                    int(value[1:])  # Check if rest is numeric\n                    if prop_id not in entity_ref_counts:\n                        entity_ref_counts[prop_id] = 0\n                    entity_ref_counts[prop_id] += 1\n                    break  # Only count once per entity\n                except ValueError:\n                    pass\n\nprint(''Properties that reference Q entities (potential relationships):'')\nfor prop, count in sorted(entity_ref_counts.items(), key=lambda x: x[1], reverse=True):\n    print(f''  {prop}: {count:,} entity references'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DATABASE RESTORE VERIFICATION ==='')\nprint()\n\ntotal = collection.count_documents({})\nprint(f''Total entities: {total:,}'')\n\n# Check for duplicates again\np61_count = collection.count_documents({''properties.P61'': {''$exists'': True}})\np62_count = collection.count_documents({''properties.P62'': {''$exists'': True}})\np63_count = collection.count_documents({''properties.P63'': {''$exists'': True}})\n\nprint(f''P61 entities: {p61_count:,}'')\nprint(f''P62 entities: {p62_count:,}'')\nprint(f''P63 entities: {p63_count:,}'')\n\n# Check for any redirects (should be 0 after restore)\nredirects = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nprint(f''Redirect entities: {redirects:,}'')\n\n# Sample a few entities to verify structure\nprint()\nprint(''Sample entity with multiple identifier properties:'')\nsample = collection.find_one({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.P62'': {''$exists'': True}\n})\n\nif sample:\n    qid = sample[''qid'']\n    p61_claims = sample[''properties''][''P61'']\n    p62_claims = sample[''properties''][''P62'']\n    print(f''{qid}:'')\n    print(f''  P61 claims: {len(p61_claims)} - {[c.get(\"\"value\"\") for c in p61_claims]}'')\n    print(f''  P62 claims: {len(p62_claims)} - {[c.get(\"\"value\"\") for c in p62_claims]}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nfrom collections import Counter\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== ANALYZING RESTORED DATABASE PROPERTIES ==='')\n\n# Get property counts  \nproperty_counts = Counter()\nfor entity in collection.find().limit(10000):\n    properties = entity.get(''properties'', {})\n    for prop_id in properties.keys():\n        property_counts[prop_id] += 1\n\nprint(''Top 15 properties in database:'')\nfor prop, count in property_counts.most_common(15):\n    print(f''  {prop}: {count:,} entities'')\n\n# Check new identifier properties specifically\np61_count = collection.count_documents({''properties.P61'': {''$exists'': True}})\np62_count = collection.count_documents({''properties.P62'': {''$exists'': True}})\np63_count = collection.count_documents({''properties.P63'': {''$exists'': True}})\n\nprint()\nprint(''Identifier properties:'')\nprint(f''P61 (Wikidata): {p61_count:,} entities'')\nprint(f''P62 (Geni): {p62_count:,} entities'')\nprint(f''P63 (UUID): {p63_count:,} entities'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING FOR FAMILY RELATIONSHIPS ==='')\n\n# Manual count for specific family properties\nfamily_props = [''P20'', ''P42'', ''P47'', ''P48'']\nprop_names = {''P20'': ''father'', ''P42'': ''mother'', ''P47'': ''child'', ''P48'': ''spouse''}\n\nfor prop in family_props:\n    count = 0\n    for entity in collection.find().limit(10000):\n        if prop in entity.get(''properties'', {}):\n            count += 1\n            if count <= 3:\n                qid = entity[''qid'']\n                claims = entity[''properties''][prop]\n                print(f''{qid} has {prop} ({prop_names[prop]}): {len(claims)} claims'')\n                for claim in claims[:1]:\n                    value = claim.get(''value'')\n                    print(f''  -> {value}'')\n    \n    print(f''Found {count} entities with {prop} ({prop_names[prop]}) in sample'')\n    print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CURRENT DATABASE STATE ==='')\ntotal = collection.count_documents({})\nprint(f''Total entities: {total:,}'')\n\n# Check for redirects\nredirect_count = 0\nfor entity in collection.find().limit(1000):\n    if ''redirect'' in entity.get(''properties'', {}):\n        redirect_count += 1\n\nprint(f''Redirects found in sample: {redirect_count}'')\n\n# Check for family relationships\nfamily_props = [''P20'', ''P42'', ''P47'', ''P48'']\nfamily_counts = {}\nfor prop in family_props:\n    count = 0\n    for entity in collection.find().limit(1000):\n        if prop in entity.get(''properties'', {}):\n            count += 1\n    family_counts[prop] = count\n\nprint(f''Family relationships in sample:'')\nfor prop, count in family_counts.items():\n    prop_names = {''P20'': ''father'', ''P42'': ''mother'', ''P47'': ''child'', ''P48'': ''spouse''}\n    print(f''  {prop} ({prop_names[prop]}): {count}'')\n\n# Check for identifier properties\nid_props = [''P61'', ''P62'', ''P63'']\nid_counts = {}\nfor prop in id_props:\n    count = 0\n    for entity in collection.find().limit(1000):\n        if prop in entity.get(''properties'', {}):\n            count += 1\n    id_counts[prop] = count\n\nprint(f''Identifier properties in sample:'')\nfor prop, count in id_counts.items():\n    prop_names = {''P61'': ''Wikidata'', ''P62'': ''Geni'', ''P63'': ''UUID''}\n    print(f''  {prop} ({prop_names[prop]}): {count}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport json\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== EXTRACTING FAMILY RELATIONSHIPS ==='')\n\nfamily_relationships = {}\nfamily_props = [''P20'', ''P42'', ''P47'', ''P48'']  # father, mother, child, spouse\ntotal_extracted = 0\n\nfor entity in collection.find():\n    # Skip redirect entities\n    if ''redirect'' in entity.get(''properties'', {}):\n        continue\n        \n    qid = entity[''qid'']\n    properties = entity.get(''properties'', {})\n    \n    entity_family = {}\n    for prop in family_props:\n        if prop in properties:\n            entity_family[prop] = properties[prop]\n            total_extracted += len(properties[prop])\n    \n    if entity_family:\n        family_relationships[qid] = entity_family\n\nprint(f''Extracted family relationships from {len(family_relationships):,} entities'')\nprint(f''Total family relationship claims: {total_extracted:,}'')\n\n# Save to JSON file for import\nwith open(''family_relationships_backup.json'', ''w'', encoding=''utf-8'') as f:\n    json.dump(family_relationships, f, indent=2, ensure_ascii=False)\n\nprint(''Family relationships saved to family_relationships_backup.json'')\n\n# Show sample\nsample_count = 0\nfor qid, relations in family_relationships.items():\n    sample_count += 1\n    if sample_count <= 3:\n        print(f''Sample: {qid} has {list(relations.keys())}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/import_single_xml.py evolutionism_complete_export.xml)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/import_our_export.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\ntotal = collection.count_documents({})\nprint(f''Current entities in database: {total:,}'')\n\n# Sample entity to verify data\nsample = collection.find_one({''properties.P61'': {''$exists'': True}})\nif sample:\n    print(f''Sample entity with P61: {sample[\"\"qid\"\"]}'')\n    p61_claims = sample[''properties''][''P61'']\n    print(f''P61 claims: {len(p61_claims)}'')\n    for claim in p61_claims[:2]:\n        print(f''  - {claim.get(\"\"value\"\")}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport json\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== APPLYING FAMILY RELATIONSHIPS ==='')\n\n# Load the family relationships from our backup\nprint(''Loading family relationships from backup...'')\nwith open(''family_relationships_backup.json'', ''r'', encoding=''utf-8'') as f:\n    family_relationships = json.load(f)\n\nprint(f''Loaded family relationships for {len(family_relationships):,} entities'')\n\n# Apply family relationships to entities in the database\napplied_count = 0\nnot_found_count = 0\nbatch_updates = []\n\nfor qid, family_props in family_relationships.items():\n    # Check if entity exists in current database\n    entity = collection.find_one({''qid'': qid})\n    if entity:\n        # Add family relationships to the entity''s properties\n        update_operations = {}\n        for prop_id, claims in family_props.items():\n            update_operations[f''properties.{prop_id}''] = claims\n        \n        if update_operations:\n            batch_updates.append(\n                pymongo.UpdateOne(\n                    {''qid'': qid},\n                    {''$set'': update_operations}\n                )\n            )\n            applied_count += 1\n            \n            # Execute in batches\n            if len(batch_updates) >= 1000:\n                collection.bulk_write(batch_updates)\n                batch_updates = []\n                print(f''  Applied family relationships to {applied_count:,} entities...'')\n    else:\n        not_found_count += 1\n\n# Execute remaining batch\nif batch_updates:\n    collection.bulk_write(batch_updates)\n\nprint()\nprint(''=== FAMILY RELATIONSHIP APPLICATION COMPLETE ==='')\nprint(f''Entities with family relationships applied: {applied_count:,}'')\nprint(f''Entities not found in current database: {not_found_count:,}'')\n\n# Verify the application\nprint()\nprint(''Verifying family relationships...'')\nfamily_props = [''P20'', ''P42'', ''P47'', ''P48'']\nfor prop in family_props:\n    count = 0\n    for entity in collection.find().limit(1000):\n        if prop in entity.get(''properties'', {}):\n            count += 1\n    prop_names = {''P20'': ''father'', ''P42'': ''mother'', ''P47'': ''child'', ''P48'': ''spouse''}\n    print(f''{prop} ({prop_names[prop]}): {count} entities in sample'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport json\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== APPLYING FAMILY RELATIONSHIPS ==='')\n\n# Load the family relationships from our backup\nprint(''Loading family relationships from backup...'')\nwith open(''family_relationships_backup.json'', ''r'', encoding=''utf-8'') as f:\n    family_relationships = json.load(f)\n\nprint(f''Loaded family relationships for {len(family_relationships):,} entities'')\n\n# Apply family relationships to entities in the database\napplied_count = 0\nnot_found_count = 0\n\nfor qid, family_props in family_relationships.items():\n    # Check if entity exists in current database\n    entity = collection.find_one({''qid'': qid})\n    if entity:\n        # Get current properties and add family relationships\n        current_properties = entity.get(''properties'', {})\n        \n        # Add family relationship properties\n        for prop_id, claims in family_props.items():\n            current_properties[prop_id] = claims\n        \n        # Update the entity with family relationships\n        collection.update_one(\n            {''qid'': qid},\n            {''$set'': {''properties'': current_properties}}\n        )\n        applied_count += 1\n        \n        if applied_count % 1000 == 0:\n            print(f''  Applied family relationships to {applied_count:,} entities...'')\n    else:\n        not_found_count += 1\n\nprint()\nprint(''=== FAMILY RELATIONSHIP APPLICATION COMPLETE ==='')\nprint(f''Entities with family relationships applied: {applied_count:,}'')\nprint(f''Entities not found in current database: {not_found_count:,}'')\n\n# Verify the application\nprint()\nprint(''Verifying family relationships...'')\nfamily_props = [''P20'', ''P42'', ''P47'', ''P48'']\nfor prop in family_props:\n    count = 0\n    for entity in collection.find().limit(1000):\n        if prop in entity.get(''properties'', {}):\n            count += 1\n    prop_names = {''P20'': ''father'', ''P42'': ''mother'', ''P47'': ''child'', ''P48'': ''spouse''}\n    print(f''{prop} ({prop_names[prop]}): {count} entities in sample'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\nimport json\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== APPLYING FAMILY RELATIONSHIPS ==='')\n\n# Load the family relationships from our backup\nprint(''Loading family relationships from backup...'')\nwith open(''family_relationships_backup.json'', ''r'', encoding=''utf-8'') as f:\n    family_relationships = json.load(f)\n\nprint(f''Loaded family relationships for {len(family_relationships):,} entities'')\n\n# Apply family relationships to entities in the database\napplied_count = 0\nnot_found_count = 0\n\nfor qid, family_props in family_relationships.items():\n    # Check if entity exists in current database\n    entity = collection.find_one({''qid'': qid})\n    if entity:\n        # Get current properties and add family relationships\n        current_properties = entity.get(''properties'', {})\n        \n        # Add family relationship properties\n        for prop_id, claims in family_props.items():\n            current_properties[prop_id] = claims\n        \n        # Update the entity with family relationships\n        result = collection.update_one(\n            {''qid'': qid},\n            {''$set'': {''properties'': current_properties}}\n        )\n        applied_count += 1\n        \n        if applied_count % 1000 == 0:\n            print(f''  Applied family relationships to {applied_count:,} entities...'')\n    else:\n        not_found_count += 1\n\nprint()\nprint(''=== FAMILY RELATIONSHIP APPLICATION COMPLETE ==='')\nprint(f''Entities with family relationships applied: {applied_count:,}'')\nprint(f''Entities not found in current database: {not_found_count:,}'')\n\n# Verify the application\nprint()\nprint(''Verifying family relationships...'')\nfamily_props = [''P20'', ''P42'', ''P47'', ''P48'']\nfor prop in family_props:\n    count = 0\n    for entity in collection.find().limit(1000):\n        if prop in entity.get(''properties'', {}):\n            count += 1\n    prop_names = {''P20'': ''father'', ''P42'': ''mother'', ''P47'': ''child'', ''P48'': ''spouse''}\n    print(f''{prop} ({prop_names[prop]}): {count} entities in sample'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\ntotal_current = collection.count_documents({})\nprint(f''Current database has: {total_current:,} entities'')\nprint()\nprint(''This explains why only 3,532 family relationships were applied!'')\nprint(''We are missing most of the database from the import!'')\n\nclient.close()\n\")",
      "Bash(mongorestore:*)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== DATABASE RESTORE VERIFICATION ==='')\nprint()\n\ntotal = collection.count_documents({})\nprint(f''Total entities: {total:,}'')\n\n# Check for duplicates again\np61_count = collection.count_documents({''properties.P61'': {''$exists'': True}})\np62_count = collection.count_documents({''properties.P62'': {''$exists'': True}})\np63_count = collection.count_documents({''properties.P63'': {''$exists'': True}})\n\nprint(f''P61 entities: {p61_count:,}'')\nprint(f''P62 entities: {p62_count:,}'')\nprint(f''P63 entities: {p63_count:,}'')\n\n# Check for any redirects (should be 0 after restore)\nredirects = collection.count_documents({''properties.redirect'': {''$exists'': True}})\nprint(f''Redirect entities: {redirects:,}'')\n\n# Sample a few entities to verify structure\nprint()\nprint(''Sample entity with multiple identifier properties:'')\nsample = collection.find_one({\n    ''properties.P61'': {''$exists'': True},\n    ''properties.P62'': {''$exists'': True}\n})\n\nif sample:\n    qid = sample[''qid'']\n    p61_claims = sample[''properties''][''P61'']\n    p62_claims = sample[''properties''][''P62'']\n    print(f''{qid}:'')\n    print(f''  P61 claims: {len(p61_claims)} - {[c.get(\"\"value\"\") for c in p61_claims]}'')\n    print(f''  P62 claims: {len(p62_claims)} - {[c.get(\"\"value\"\") for c in p62_claims]}'')\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== CHECKING FOR FAMILY RELATIONSHIPS ==='')\n\n# Manual count for specific family properties\nfamily_props = [''P20'', ''P42'', ''P47'', ''P48'']\nprop_names = {''P20'': ''father'', ''P42'': ''mother'', ''P47'': ''child'', ''P48'': ''spouse''}\n\nfor prop in family_props:\n    count = 0\n    for entity in collection.find().limit(10000):\n        if prop in entity.get(''properties'', {}):\n            count += 1\n            if count <= 3:\n                qid = entity[''qid'']\n                claims = entity[''properties''][prop]\n                print(f''{qid} has {prop} ({prop_names[prop]}): {len(claims)} claims'')\n                for claim in claims[:1]:\n                    value = claim.get(''value'')\n                    print(f''  -> {value}'')\n    \n    print(f''Found {count} entities with {prop} ({prop_names[prop]}) in sample'')\n    print()\n\nclient.close()\n\")",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" gedcom_tools/combine_family_and_processed_data.py)",
      "Bash(\"C:\\Users\\Immanuelle\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\" -c \"\nimport pymongo\n\nclient = pymongo.MongoClient(''mongodb://localhost:27017/'')\ndb = client[''gaiad_processing_db'']\ncollection = db[''entities'']\n\nprint(''=== VERIFYING COMBINED DATABASE ==='')\nprint()\n\ntotal = collection.count_documents({})\nprint(f''Total entities: {total:,}'')\n\n# Check for family relationships\nfamily_props = [''P20'', ''P42'', ''P47'', ''P48'']\nentities_with_family = 0\n\nfor entity in collection.find().limit(5000):  # Sample first 5k\n    properties = entity.get(''properties'', {})\n    has_family = any(prop in properties for prop in family_props)\n    if has_family:\n        entities_with_family += 1\n\nprint(f''Entities with family relationships (sample): {entities_with_family:,}'')\n\n# Check for processed identifiers\np61_count = 0\np62_count = 0\np63_count = 0\n\nfor entity in collection.find().limit(5000):\n    properties = entity.get(''properties'', {})\n    if ''P61'' in properties:\n        p61_count += 1\n    if ''P62'' in properties:\n        p62_count += 1\n    if ''P63'' in properties:\n        p63_count += 1\n\nprint(f''Entities with P61 (Wikidata) in sample: {p61_count:,}'')\nprint(f''Entities with P62 (Geni) in sample: {p62_count:,}'')\nprint(f''Entities with P63 (UUID) in sample: {p63_count:,}'')\n\n# Check for labels\nentities_with_labels = 0\nfor entity in collection.find().limit(1000):\n    if entity.get(''labels'', {}):\n        entities_with_labels += 1\n\nprint(f''Entities with labels (sample): {entities_with_labels:,}'')\n\n# Show sample entity with both family and identifiers\nsample = collection.find_one({\n    ''properties.P20'': {''$exists'': True},\n    ''properties.P61'': {''$exists'': True}\n})\n\nif sample:\n    qid = sample[''qid'']\n    label = sample.get(''labels'', {}).get(''en'', ''No label'')\n    print(f'''')\n    print(f''Sample entity with BOTH family + identifiers:'')\n    print(f''  QID: {qid}'')\n    print(f''  Label: {label}'')\n    \n    # Show family relationships\n    family_count = 0\n    for prop in family_props:\n        if prop in sample.get(''properties'', {}):\n            family_count += len(sample[''properties''][prop])\n    print(f''  Family relationships: {family_count} claims'')\n    \n    # Show identifiers\n    id_count = 0\n    for prop in [''P61'', ''P62'', ''P63'']:\n        if prop in sample.get(''properties'', {}):\n            id_count += len(sample[''properties''][prop])\n    print(f''  Identifier claims: {id_count} claims'')\n\nclient.close()\n\")"
    ],
    "deny": [],
    "defaultMode": "acceptEdits",
    "additionalDirectories": [
      "C:\\Users\\Immanuelle\\Documents\\Github"
    ]
  }
}